<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å°ˆæ¥­å®¤å…§ä½ˆå±€ç·¨è¼¯å™¨ (v10.0 - å…¨åŠŸèƒ½)</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        /* --- åŸºæœ¬é é¢æ¨£å¼ --- */
        html, body { height: 100%; overflow: hidden; }
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f2f5;
            display: flex;
            height: 100vh;
        }

        /* --- æ§åˆ¶é¢æ¿ (å·¦å´) --- */
        .controls {
            width: 300px;
            flex-shrink: 0;
            padding: 20px;
            background-color: #fff;
            box-shadow: 2px 0 8px rgba(0,0,0,0.1);
            overflow-y: auto;
            z-index: 100;
            height: 100vh;
            box-sizing: border-box;
        }
        
        .controls h3 { margin-top: 20px; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        .controls h3:first-child { margin-top: 0; }
        .control-group { margin-bottom: 15px; }
        .controls label { display: block; margin-bottom: 5px; font-weight: bold; font-size: 14px; }
        .controls input[type="text"],
        .controls input[type="number"],
        .controls select,
        .controls textarea {
            width: calc(100% - 20px); 
            padding: 8px; 
            border: 1px solid #ccc; 
            border-radius: 4px; 
            font-family: monospace;
            font-size: 12px;
        }
        .controls select { font-family: Arial, sans-serif; font-size: 14px; }
        .controls input[type="text"],
        .controls input[type="number"] { font-family: Arial, sans-serif; font-size: 14px; }
        .controls input[type="range"] { width: 100%; padding: 0; }
        .controls input[type="color"] { padding: 0; height: 35px; width: 100%; }
        
        .controls button { width: 100%; padding: 10px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; transition: background-color 0.2s; margin-top: 5px; }
        .controls button:hover { background-color: #0056b3; }
        .controls button.secondary { background-color: #6c757d; }
        .controls button.secondary:hover { background-color: #5a6268; }
        .controls button.success { background-color: #28a745; }
        .controls button.success:hover { background-color: #218838; }
        .controls button.danger { background-color: #dc3545; }
        .controls button.danger:hover { background-color: #c82333; }
        .controls button.info { background-color: #17a2b8; } /* (æ–°) */
        .controls button.info:hover { background-color: #138496; }
        .controls button.warning { background-color: #ffc107; color:#333; } /* (æ–°) */
        .controls button.warning:hover { background-color: #e0a800; }
        
        .controls button:disabled,
        .controls button:disabled:hover {
            background-color: #c6c6c6;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .control-row { display: flex; gap: 10px; }
        .control-row button { width: 100%; font-size: 14px; padding: 8px;} /* (ä¿®æ”¹) æŒ‰éˆ•å°ä¸€é» */
        
        .checkbox-group { display: flex; align-items: center; gap: 10px; }
        .checkbox-group label { margin-bottom: 0; font-weight: normal; }
        
        /* (æ–°) ç‰©ä»¶åº«æ¨£å¼ */
        #libraryItems {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
            margin-top: 10px;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }
        .library-item {
            aspect-ratio: 1 / 1; /* æ­£æ–¹å½¢ */
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            background-color: #f8f9fa;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .library-item:hover { background-color: #e9ecef; }
        .library-item-preview {
             /* é è¦½è‰²å¡Šæ¨£å¼, JS æœƒå‹•æ…‹è¨­å®š */
            width: 70%;
            height: 70%;
            border: 1px dashed #aaa;
            box-sizing: border-box;
            transform-origin: center;
        }
        .library-item-label {
            position: absolute;
            bottom: 2px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 10px;
            color: #555;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .library-item button.delete-lib-item { /* (æ–°) åˆªé™¤åº«é …ç›®æŒ‰éˆ• */
            position: absolute;
            top: 1px;
            right: 1px;
            width: 18px;
            height: 18px;
            line-height: 14px;
            padding: 0;
            font-size: 12px;
            background-color: rgba(220, 53, 69, 0.7);
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            z-index: 1;
        }

        /* --- æ¨¡æ“¬å€åŸŸ (å³å´) --- */
        #canvas-wrapper {
            flex-grow: 1;
            height: 100vh;
            overflow: auto;
            background-color: #e9ebee;
            -webkit-overflow-scrolling: touch;
            cursor: default; /* (æ–°) é è¨­æ¸¸æ¨™ */
        }
        /* (æ–°) å¹³ç§»æ¨¡å¼ä¸‹çš„æ¸¸æ¨™ */
        #canvas-wrapper.pan-mode { cursor: grab; }
        #canvas-wrapper.pan-mode:active { cursor: grabbing; }

        #canvas {
            position: relative;
            width: 5000px;
            height: 5000px;
            background-color: #f8f9fa;
            background-image: linear-gradient(rgba(0,0,0,0.05) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(0,0,0,0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            transform-origin: top left;
            transition: transform 0.2s ease-out;
        }
        
        /* (æ–°) æ‹–æ›³é¸æ¡† */
        #selectionBox {
            position: absolute;
            border: 1px dashed #007bff;
            background-color: rgba(0, 123, 255, 0.1);
            pointer-events: none; /* è®“æ»‘é¼ å¯ä»¥ç©¿é€ */
            z-index: 9999;
            display: none; /* é è¨­éš±è— */
        }


        /* --- æˆ¿é–“ (ç•«å¸ƒ) --- */
        .room {
            position: absolute; 
            background-color: #ffffff;
            border: 2px solid #aaa; /* (ä¿®æ”¹) é è¨­é‚Šæ¡†ç´°ä¸€é» */
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            box-sizing: border-box;
            transition: border-color 0.2s, transform 0.2s, box-shadow 0.2s;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            transform-origin: center;
            z-index: 50; /* (æ–°) æˆ¿é–“çš„åŸºç¤ z-index */
        }
        .room:active { cursor: grabbing; }
        .room.selected { /* (æ–°) å¤šé‡é¸å–æ¨£å¼ */
            border: 3px solid #007bff;
            box-shadow: 0 0 15px rgba(0,123,255,0.3);
            z-index: 51; /* é¸ä¸­æ™‚æé«˜ä¸€é» */
        }

        /* --- æˆ¿é–“æ¨™ç±¤ --- */
        .room-label {
            position: absolute;
            font-size: var(--font-size, 14px); 
            font-weight: bold;
            color: rgba(0,0,0,0.25);
            pointer-events: none;
            user-select: none;
            white-space: nowrap;
        }
        .label-room-main { position: relative; }
        .label-room-width { bottom: 5px; left: 50%; transform: translateX(-50%); }
        .label-room-height { right: 8px; top: 50%; transform: translateY(-50%) rotate(90deg); transform-origin: center; }
        
        /* --- å®¶å…· (è‰²å¡Š) --- */
        .furniture {
            position: absolute; 
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            border: 2px solid #555;
            transition: left 0.1s ease-out, top 0.1s ease-out, border-color 0.2s, background-color 0.2s, transform 0.2s, box-shadow 0.2s;
            z-index: 100; /* (æ–°) å®¶å…·çš„åŸºç¤ z-index */
            transform-origin: center;
        }
        
        .furniture.selected { /* (æ–°) å¤šé‡é¸å–æ¨£å¼ */
            border: 3px solid #007bff;
            box-shadow: 0 0 15px rgba(0,123,255,0.3);
            z-index: 500; /* é¸ä¸­æ™‚æœ€é«˜ */
        }

        /* --- å®¶å…·æ¨™ç±¤ --- */
        .furniture-label {
            position: absolute;
            font-size: var(--font-size, 14px);
            color: #1f1f1f;
            text-shadow: 0 0 3px rgba(255,255,255,0.9);
            pointer-events: none;
            user-select: none;
            white-space: nowrap;
        }
        .label-main { position: relative; font-weight: bold; }
        .label-width { bottom: 2px; left: 50%; transform: translateX(-50%); }
        .label-height { right: 5px; top: 50%; transform: translateY(-50%) rotate(90deg); transform-origin: center; }
        
        .furniture.colliding {
            border: 3px solid #dc3545 !important;
            box-shadow: 0 0 10px rgba(220, 53, 69, 0.5);
            z-index: 1001 !important;
            transition: none; 
        }
        
        /* --- æ‰‹æ©Ÿç‰ˆéŸ¿æ‡‰å¼æ¨£å¼ --- */
        @media (max-width: 768px) {
            body { flex-direction: column; height: 100vh; }
            .controls { width: 100%; height: 40vh; flex-shrink: 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
            #canvas-wrapper { height: 60vh; }
        }

    </style>
</head>
<body>

    <!-- 1. æ§åˆ¶é¢æ¿ (HTML) -->
    <div class="controls">
        <h3>è¦–åœ–æ§åˆ¶</h3>
        <div class="control-group control-row">
            <button id="zoomInBtn">+</button>
            <button id="zoomOutBtn">-</button>
            <button id="zoomResetBtn">100%</button>
        </div>
        <div class="control-group control-row">
            <button id="undoBtn" class="secondary" disabled>ä¸Šä¸€æ­¥</button>
            <button id="redoBtn" class="secondary" disabled>ä¸‹ä¸€æ­¥</button>
            <!-- (æ–°) å¹³ç§»æ¨¡å¼æŒ‰éˆ• -->
            <button id="panModeBtn" class="secondary">å¹³ç§»æ¨¡å¼ (ğŸ–ï¸)</button> 
        </div>
        
        <h3>å°ˆæ¡ˆ (åˆ†äº«/åŒ¯å…¥)</h3>
        <div class="control-group">
            <label for="importExportArea">ä½ˆå±€ä»£ç¢¼ (æ©Ÿå™¨ç¢¼)</label>
            <textarea id="importExportArea" rows="4" placeholder="è²¼ä¸Šä»£ç¢¼, æˆ–é»æ“Šä¸‹æ–¹åŒ¯å‡º..."></textarea>
            <button id="importTextBtn" class="secondary" style="margin-top:10px;">å¾ä»£ç¢¼åŒ¯å…¥</button>
            <button id="exportTextBtn">åŒ¯å‡ºç‚ºä»£ç¢¼</button>
        </div>
        <div class="control-group">
            <button id="exportImageBtn" class="secondary">è¼¸å‡ºç‚ºåœ–ç‰‡ (PNG)</button>
            <button id="clearBtn" class="danger">æ¸…ç©ºæ‰€æœ‰</button>
        </div>

        <h3>ç·¨è¼¯é¸ä¸­é …ç›®</h3>
        <div class="control-group">
            <p id="selectionInfo" style="font-size: 13px; color: #555;">(è«‹é»æ“Š/è§¸æ§ç•«å¸ƒä¸Šçš„é …ç›®)</p>
             <!-- (æ–°) åœ–å±¤æŒ‰éˆ• -->
            <div class="control-row" style="margin-bottom: 10px;">
                <button id="bringForwardBtn" class="info" disabled>ä¸Šç§»ä¸€å±¤</button>
                <button id="sendBackwardBtn" class="info" disabled>ä¸‹ç§»ä¸€å±¤</button>
            </div>
            <div class="control-row" style="margin-bottom: 10px;">
                <button id="bringToFrontBtn" class="info" disabled>ç½®æ–¼é ‚å±¤</button>
                <button id="sendToBackBtn" class="info" disabled>ç½®æ–¼åº•å±¤</button>
            </div>
             <!-- (æ–°) ç¾¤çµ„æŒ‰éˆ• -->
            <div class="control-row" style="margin-bottom: 10px;">
                <button id="groupBtn" class="warning" disabled>è¨­ç‚ºç¾¤çµ„</button>
                <button id="ungroupBtn" class="warning" disabled>å–æ¶ˆç¾¤çµ„</button>
            </div>
            <button id="updateBtn" class="success" disabled>æ›´æ–°å±¬æ€§</button>
            <button id="deleteBtn" class="danger" disabled>åˆªé™¤é¸ä¸­é …ç›®</button>
        </div>
        <div class="control-group checkbox-group">
            <input type="checkbox" id="preventOverlap">
            <label for="preventOverlap">ç¦æ­¢å®¶å…·é‡ç–Š (é™0/90åº¦)</label>
        </div>
        <div class="control-group checkbox-group">
            <input type="checkbox" id="enableSnapping" checked>
            <label for="enableSnapping">å•Ÿç”¨é‚Šç·£å¸é™„ (é™0/90åº¦)</label>
        </div>

        <!-- (æ–°) ç‰©ä»¶åº« -->
        <h3>ç‰©ä»¶åº«</h3>
        <div class="control-group">
            <button id="saveToLibraryBtn" class="info" disabled>å„²å­˜é¸ä¸­è‡³åº«</button>
            <div id="libraryItems">
                <!-- åº«é …ç›®æœƒå‹•æ…‹åŠ è¼‰æ–¼æ­¤ -->
            </div>
        </div>


        <h3>æ–°å¢é …ç›®</h3>
        <div style="border:1px solid #eee; padding: 15px; border-radius: 5px;">
            <h4>æ–°å¢æˆ¿é–“</h4>
            <div class="control-group">
                <label for="roomWidth">å¯¬åº¦ (cm)</label>
                <input type="number" id="roomWidth" value="500">
            </div>
            <div class="control-group">
                <label for="roomHeight">é•·åº¦ (cm)</label>
                <input type="number" id="roomHeight" value="400">
            </div>
            <div class="control-group">
                <label for="roomLabel">å‚™è¨»</label>
                <input type="text" id="roomLabel" value="å®¢å»³">
            </div>
            <div class="control-group">
                <label for="roomFontSize">æ–‡å­—å¤§å° (px)</label>
                <input type="number" id="roomFontSize" value="14" min="8" max="100">
            </div>
            <div class="control-group">
                <label for="roomRotation">æ—‹è½‰è§’åº¦ (deg)</label>
                <input type="number" id="roomRotation" value="0" step="1">
            </div>
            <button id="addRoomBtn">æ–°å¢æˆ¿é–“</button>
        </div>
        
        <div style="border:1px solid #eee; padding: 15px; border-radius: 5px; margin-top:15px;">
            <h4>æ–°å¢å®¶å…·</h4>
            <div class="control-group">
                <label for="furnWidth">å¯¬åº¦ (cm)</label>
                <input type="number" id="furnWidth" value="180">
            </div>
            <div class="control-group">
                <label for="furnHeight">é•·åº¦ (cm)</label>
                <input type="number" id="furnHeight" value="90">
            </div>
            <div class="control-group">
                <label for="furnShape">å½¢ç‹€</label>
                <select id="furnShape">
                    <option value="rectangle">å››æ–¹å½¢</option>
                    <option value="circle">åœ“å½¢/æ©¢åœ“</option>
                </select>
            </div>
            <div class="control-group">
                <label for="furnColor">é¡è‰²</label>
                <input type="color" id="furnColor" value="#a3b18a">
            </div>
            <div class="control-group">
                <label for="furnOpacity">é€æ˜åº¦ (<span id="opacityValue">100</span>%)</label>
                <input type="range" id="furnOpacity" min="10" max="100" value="100">
            </div>
            <div class="control-group">
                <label for="furnLabel">å‚™è¨»</label>
                <input type="text" id="furnLabel" value="æ²™ç™¼">
            </div>
            <div class="control-group">
                <label for="furnFontSize">æ–‡å­—å¤§å° (px)</label>
                <input type="number" id="furnFontSize" value="14" min="8" max="100">
            </div>
            <div class="control-group">
                <label for="furnRotation">æ—‹è½‰è§’åº¦ (deg)</label>
                <input type="number" id="furnRotation" value="0" step="1">
            </div>
            <button id="addFurnitureBtn">æ–°å¢å®¶å…·</button>
        </div>
    </div>

    <!-- 2. æ¨¡æ“¬å€åŸŸ (HTML) -->
    <div id="canvas-wrapper">
        <div id="canvas">
            <!-- æˆ¿é–“å’Œå®¶å…·éƒ½æœƒæ–°å¢æ–¼æ­¤ -->
        </div>
        <!-- (æ–°) æ‹–æ›³é¸æ¡† -->
        <div id="selectionBox"></div>
    </div>

    <script>
        // 3. JavaScript åŠŸèƒ½å¯¦ç¾

        // --- æ¯”ä¾‹å°º & å¸¸æ•¸ ---
        const SCALE = 1.5; 
        const SNAP_DISTANCE = 10;
        const Z_INDEX_ROOM_BASE = 50;   // (æ–°)
        const Z_INDEX_FURN_BASE = 100;  // (æ–°)
        const Z_INDEX_STEP = 1;         // (æ–°)

        // ç²å–å…ƒç´ 
        const controlsPanel = document.querySelector('.controls'); // (æ–°)
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const canvas = document.getElementById('canvas');
        const addRoomBtn = document.getElementById('addRoomBtn');
        const addFurnitureBtn = document.getElementById('addFurnitureBtn');
        const opacitySlider = document.getElementById('furnOpacity');
        const opacityValue = document.getElementById('opacityValue');
        const selectionBox = document.getElementById('selectionBox'); // (æ–°)
        const selectionInfo = document.getElementById('selectionInfo'); // (æ–°)
        
        // å…¨å±€è®Šæ•¸
        let selectedItems = []; // (æ–°) å¤šé¸é™£åˆ—
        let zoomLevel = 1.0;
        let isPanMode = false; // (æ–°)
        let panStartX = 0, panStartY = 0, scrollStartX = 0, scrollStartY = 0; // (æ–°)
        let isSelectingBox = false; // (æ–°)
        let selectionStartX = 0, selectionStartY = 0; // (æ–°)
        
        // --- æ­·å²ç´€éŒ„åŠŸèƒ½è®Šæ•¸ ---
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        let historyStack = [];
        let redoStack = [];
        let stateBeforeDrag = null;
        let dragOffsetX = 0, dragOffsetY = 0;

        // --- è¼”åŠ©å‡½å¼ï¼šå–å¾—äº‹ä»¶åº§æ¨™ ---
        function getEventCoords(e) {
            if (e.touches && e.touches.length) {
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
            // (æ–°) è€ƒæ…®è§¸æ§çµæŸäº‹ä»¶ e.changedTouches
            if (e.changedTouches && e.changedTouches.length) {
                return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
            }
            return { x: e.clientX, y: e.clientY };
        }

        // --- è¼”åŠ©å‡½å¼ï¼šHex è½‰ RGB ---
        function hexToRgb(hex) {
            let r = 0, g = 0, b = 0;
            if (!hex) return {r:0,g:0,b:0}; // (æ–°) é˜²ç¦¦ nil
            if (hex.length == 4) {
                r = parseInt(hex[1] + hex[1], 16); g = parseInt(hex[2] + hex[2], 16); b = parseInt(hex[3] + hex[3], 16);
            } else if (hex.length == 7) {
                r = parseInt(hex.substring(1, 3), 16); g = parseInt(hex.substring(3, 5), 16); b = parseInt(hex.substring(5, 7), 16);
            }
            return { r, g, b };
        }
        
        // æ›´æ–°é€æ˜åº¦æ»‘æ¡¿æ–‡å­—
        opacitySlider.oninput = function() {
            opacityValue.innerText = this.value;
        }

        // --- åŠŸèƒ½ A: è¦–åœ–ç¸®æ”¾ (æ»¾è¼ª) ---
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomResetBtn = document.getElementById('zoomResetBtn');

        function applyZoom(newZoomLevel, centerX, centerY) {
            const currentZoom = zoomLevel;
            newZoomLevel = Math.max(0.2, Math.min(newZoomLevel, 3.0)); // é™åˆ¶ç¯„åœ
            
            if (newZoomLevel === currentZoom) return;

            const scrollX = canvasWrapper.scrollLeft;
            const scrollY = canvasWrapper.scrollTop;

            // ç›¸å°æ–¼ç•«å¸ƒå·¦ä¸Šè§’çš„ç¸®æ”¾ä¸­å¿ƒé»
            const canvasRect = canvas.getBoundingClientRect();
            const relativeX = centerX - canvasRect.left;
            const relativeY = centerY - canvasRect.top;

            // è¨ˆç®—ç¸®æ”¾å‰å¾Œä¸­å¿ƒé»çš„ä½ç§»
            const dx = (relativeX / currentZoom) * (newZoomLevel - currentZoom);
            const dy = (relativeY / currentZoom) * (newZoomLevel - currentZoom);

            zoomLevel = newZoomLevel;
            canvas.style.transform = `scale(${zoomLevel})`;

            // èª¿æ•´æ»¾å‹•ä½ç½®ä»¥ä¿æŒä¸­å¿ƒé»
            canvasWrapper.scrollLeft = scrollX + dx;
            canvasWrapper.scrollTop = scrollY + dy;
        }

        zoomInBtn.onclick = () => { 
            const rect = canvasWrapper.getBoundingClientRect();
            applyZoom(zoomLevel + 0.1, rect.left + rect.width / 2, rect.top + rect.height / 2);
        };
        zoomOutBtn.onclick = () => { 
            const rect = canvasWrapper.getBoundingClientRect();
            applyZoom(zoomLevel - 0.1, rect.left + rect.width / 2, rect.top + rect.height / 2);
         };
        zoomResetBtn.onclick = () => { 
             const rect = canvasWrapper.getBoundingClientRect();
            applyZoom(1.0, rect.left + rect.width / 2, rect.top + rect.height / 2);
         };
         
        // (æ–°) æ»¾è¼ªç¸®æ”¾
        canvasWrapper.addEventListener('wheel', (e) => {
            if (isPanMode) return; // å¹³ç§»æ¨¡å¼ä¸‹ç¦ç”¨æ»¾è¼ªç¸®æ”¾
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            applyZoom(zoomLevel + delta, e.clientX, e.clientY);
        }, { passive: false }); // éœ€è¦ preventDefault

        
        // --- åŠŸèƒ½ B: æ­·å²ç´€éŒ„ (Undo/Redo) ---
        
        // B-1: å–å¾—ç›®å‰ç‹€æ…‹
        function getCurrentState() {
            const layoutData = { rooms: [], furniture: [] };
            canvas.querySelectorAll('.room').forEach(room => {
                layoutData.rooms.push({
                    id: room.dataset.id, // (æ–°) å„²å­˜ ID
                    left: room.style.left, top: room.style.top,
                    width: room.style.width, height: room.style.height,
                    cmWidth: room.dataset.cmWidth, cmHeight: room.dataset.cmHeight,
                    label: room.dataset.label, fontSize: room.dataset.fontSize,
                    rotation: room.dataset.rotation, zIndex: room.style.zIndex || Z_INDEX_ROOM_BASE // (æ–°) zIndex
                });
            });
            canvas.querySelectorAll('.furniture').forEach(f => {
                layoutData.furniture.push({
                    id: f.dataset.id, // (æ–°) å„²å­˜ ID
                    groupId: f.dataset.groupId || null, // (æ–°) å„²å­˜ç¾¤çµ„ ID
                    left: f.style.left, top: f.style.top,
                    width: f.style.width, height: f.style.height,
                    color: f.dataset.colorHex, opacity: f.dataset.opacity,
                    shape: f.style.borderRadius === '50%' ? 'circle' : 'rectangle',
                    label: f.dataset.label, cmWidth: f.dataset.cmWidth, cmHeight: f.dataset.cmHeight,
                    fontSize: f.dataset.fontSize, rotation: f.dataset.rotation,
                    zIndex: f.style.zIndex || Z_INDEX_FURN_BASE // (æ–°) zIndex
                });
            });
            return layoutData;
        }

        // B-2: è¼‰å…¥ç‹€æ…‹
        function loadLayout(layoutData) {
            clearSelection(); // (æ–°) æ¸…é™¤é¸å–
            clearCanvas(false); 
            if (!layoutData) { console.error("Invalid layout data to load."); return; }
            
            (layoutData.rooms || []).forEach((roomData) => {
                const fontSize = roomData.fontSize || 14;
                const rotation = roomData.rotation || 0;
                const room = createRoomElement(roomData.cmWidth, roomData.cmHeight, roomData.label, fontSize, rotation, roomData.id);
                room.style.left = roomData.left; room.style.top = roomData.top;
                room.style.zIndex = roomData.zIndex || Z_INDEX_ROOM_BASE; // (æ–°)
                canvas.appendChild(room);
                makeDraggable(room); // (æ–°) çµ±ä¸€çš„æ‹–æ›³å‡½å¼
            });
            
            (layoutData.furniture || []).forEach(furnData => {
                const opacity = furnData.opacity || 1; 
                const fontSize = furnData.fontSize || 14;
                const rotation = furnData.rotation || 0;
                const furniture = createFurnitureElement(furnData.cmWidth, furnData.cmHeight, furnData.shape, furnData.color, furnData.label, opacity, fontSize, rotation, furnData.id);
                furniture.style.left = furnData.left; furniture.style.top = furnData.top;
                furniture.style.zIndex = furnData.zIndex || Z_INDEX_FURN_BASE; // (æ–°)
                if (furnData.groupId) furniture.dataset.groupId = furnData.groupId; // (æ–°)
                canvas.appendChild(furniture);
                makeDraggable(furniture); // (æ–°) çµ±ä¸€çš„æ‹–æ›³å‡½å¼
            });
        }
        
        // B-3: æ›´æ–° Undo/Redo æŒ‰éˆ•ç‹€æ…‹
        function updateUndoRedoButtons() {
            undoBtn.disabled = historyStack.length === 0;
            redoBtn.disabled = redoStack.length === 0;
        }

        // B-4: å„²å­˜ä¸€å€‹å‹•ä½œåˆ°æ­·å²
        function saveStateForUndo(actionDescription = "") { // (æ–°) å¯é¸æè¿°
             // console.log("Saving state for:", actionDescription); // Debug
            redoStack = []; 
            historyStack.push(getCurrentState());
            if (historyStack.length > 50) historyStack.shift();
            updateUndoRedoButtons();
        }
        
        // B-5: æŒ‰ä¸‹ Undo
        undoBtn.onclick = function() {
            if (historyStack.length === 0) return;
            redoStack.push(getCurrentState());
            loadLayout(historyStack.pop());
            updateUndoRedoButtons();
        };

        // B-6: æŒ‰ä¸‹ Redo
        redoBtn.onclick = function() {
            if (redoStack.length === 0) return;
            historyStack.push(getCurrentState());
            loadLayout(redoStack.pop());
            updateUndoRedoButtons();
        };

        // --- åŠŸèƒ½ C: å°ˆæ¡ˆ (ä»£ç¢¼åŒ¯å…¥/åŒ¯å‡º) ---
        const importTextBtn = document.getElementById('importTextBtn');
        const exportTextBtn = document.getElementById('exportTextBtn');
        const exportImageBtn = document.getElementById('exportImageBtn');
        const clearBtn = document.getElementById('clearBtn');
        const importExportArea = document.getElementById('importExportArea');

        // C-1: åŒ¯å‡ºç‚ºä»£ç¢¼
        exportTextBtn.onclick = function() {
            importExportArea.value = JSON.stringify(getCurrentState(), null, 2);
            alert('ä»£ç¢¼å·²åŒ¯å‡ºåˆ°ä¸Šæ–¹çš„æ–‡å­—æ¡†ï¼');
        };

        // C-2: å¾ä»£ç¢¼åŒ¯å…¥
        importTextBtn.onclick = function() {
            const dataString = importExportArea.value;
            if (!dataString) { alert('è«‹å…ˆåœ¨æ–‡å­—æ¡†ä¸­è²¼ä¸Šä½ˆå±€ä»£ç¢¼ã€‚'); return; }
            let layoutData;
            try { layoutData = JSON.parse(dataString); } 
            catch (e) { alert('ä»£ç¢¼æ ¼å¼éŒ¯èª¤ï¼Œç„¡æ³•è§£æã€‚\n' + e.message); return; }
            
            historyStack = []; 
            redoStack = [];
            loadLayout(layoutData);
            historyStack.push(getCurrentState()); 
            updateUndoRedoButtons();
            
            alert('ä½ˆå±€å·²å¾ä»£ç¢¼è¼‰å…¥ï¼');
        };

        // C-3: è¼¸å‡ºåœ–ç‰‡
        exportImageBtn.onclick = function() {
            if (typeof html2canvas === 'undefined') { alert('éŒ¯èª¤ï¼šåœ–ç‰‡è¼¸å‡ºå‡½å¼åº«è¼‰å…¥å¤±æ•—ã€‚'); return; }
            alert('æ­£åœ¨æº–å‚™è¼¸å‡ºåœ–ç‰‡... è«‹ç¨å€™ã€‚');
            clearSelection();
            
            html2canvas(canvas, { useCORS: true, backgroundColor: '#e9ebee' })
            .then(canvasImage => {
                const link = document.createElement('a');
                link.download = 'my-layout.png';
                link.href = canvasImage.toDataURL('image/png');
                link.click();
            }).catch(err => { alert('è¼¸å‡ºå¤±æ•—: ' + err.message); });
        };

        // C-4: æ¸…ç©ºç•«å¸ƒ
        clearBtn.onclick = function() {
            if (confirm('ç¢ºå®šè¦æ¸…ç©ºæ‰€æœ‰æˆ¿é–“å’Œå®¶å…·å—ï¼Ÿ')) {
                saveStateForUndo("Clear Canvas"); 
                clearCanvas(false); 
                updateUndoRedoButtons();
            }
        };
        
        function clearCanvas(saveHistory = true) {
            if (saveHistory) saveStateForUndo("Clear Canvas Internal");
            canvas.innerHTML = '';
            // activeRoom = null; // ç”± clearSelection è™•ç†
            // activeFurniture = null;
            clearSelection();
            if (saveHistory) updateUndoRedoButtons();
        }

        // --- (*** é‡æ§‹ ***) åŠŸèƒ½ D: é¸å–ç®¡ç† (æ”¯æ´å¤šé¸) ---
        
        const updateBtn = document.getElementById('updateBtn');
        const deleteBtn = document.getElementById('deleteBtn');
        const bringForwardBtn = document.getElementById('bringForwardBtn');
        const sendBackwardBtn = document.getElementById('sendBackwardBtn');
        const bringToFrontBtn = document.getElementById('bringToFrontBtn');
        const sendToBackBtn = document.getElementById('sendToBackBtn');
        const groupBtn = document.getElementById('groupBtn');
        const ungroupBtn = document.getElementById('ungroupBtn');
        const saveToLibraryBtn = document.getElementById('saveToLibraryBtn');


        // D-1: æ¸…é™¤æ‰€æœ‰é¸å–
        function clearSelection() {
            selectedItems.forEach(item => item.classList.remove('selected'));
            selectedItems = [];
            updateSelectionUI();
        }

        // D-2: è¨­å®šé¸å– (æ ¸å¿ƒ)
        function setSelection(items) {
            clearSelection(); // å…ˆæ¸…é™¤èˆŠçš„
            selectedItems = Array.isArray(items) ? items : [items]; // ç¢ºä¿æ˜¯é™£åˆ—
            selectedItems.forEach(item => item.classList.add('selected'));
            updateSelectionUI();
        }
        
        // D-3: åˆ‡æ›å–®ä¸€ç‰©ä»¶çš„é¸å–ç‹€æ…‹
        function toggleSelection(item, isShiftKey) {
            const groupId = item.dataset.groupId;
            let itemsToToggle = [item];

            // å¦‚æœé»æ“Šçš„æ˜¯ç¾¤çµ„ç‰©ä»¶ï¼Œé¸å–æ•´å€‹ç¾¤çµ„
            if (groupId) {
                itemsToToggle = Array.from(canvas.querySelectorAll(`[data-group-id="${groupId}"]`));
            }

            if (isShiftKey) {
                // Shift éµï¼šåŠ å…¥/ç§»å‡ºé¸å–
                itemsToToggle.forEach(it => {
                    const index = selectedItems.indexOf(it);
                    if (index > -1) {
                        selectedItems.splice(index, 1);
                        it.classList.remove('selected');
                    } else {
                        selectedItems.push(it);
                        it.classList.add('selected');
                    }
                });
            } else {
                // æ²’æœ‰ Shift éµï¼š
                // 1. å¦‚æœé»æ“Šçš„ç‰©ä»¶(æˆ–å…¶ç¾¤çµ„)å·²åœ¨é¸å–ä¸­ -> ä¸è®Š (å…è¨±ç›´æ¥æ‹–æ›³)
                // 2. å¦‚æœé»æ“Šçš„ç‰©ä»¶(æˆ–å…¶ç¾¤çµ„)ä¸åœ¨é¸å–ä¸­ -> åªé¸å–å®ƒ(å€‘)
                const alreadySelected = itemsToToggle.every(it => selectedItems.includes(it));
                if (!alreadySelected) {
                    setSelection(itemsToToggle);
                }
            }
            updateSelectionUI();
        }


        // D-4: æ›´æ–° UI ç‹€æ…‹ (æŒ‰éˆ•å•Ÿç”¨/ç¦ç”¨, è¡¨å–®å…§å®¹)
        function updateSelectionUI() {
            const count = selectedItems.length;
            
            // æ›´æ–°æç¤ºæ–‡å­—
            if (count === 0) {
                selectionInfo.textContent = "(è«‹é»æ“Š/è§¸æ§ç•«å¸ƒä¸Šçš„é …ç›®)";
            } else if (count === 1) {
                selectionInfo.textContent = `å·²é¸å– 1 å€‹é …ç›® (${selectedItems[0].dataset.label})`;
            } else {
                selectionInfo.textContent = `å·²é¸å– ${count} å€‹é …ç›®`;
            }

            // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
            updateBtn.disabled = count !== 1; // åªèƒ½æ›´æ–°å–®ä¸€ç‰©ä»¶
            deleteBtn.disabled = count === 0;
            bringForwardBtn.disabled = count !== 1;
            sendBackwardBtn.disabled = count !== 1;
            bringToFrontBtn.disabled = count !== 1;
            sendToBackBtn.disabled = count !== 1;
            groupBtn.disabled = count < 2; // è‡³å°‘è¦é¸ 2 å€‹æ‰èƒ½ç¾¤çµ„
            ungroupBtn.disabled = count === 0 || !selectedItems.some(item => item.dataset.groupId); // è‡³å°‘è¦é¸ä¸€å€‹åœ¨ç¾¤çµ„ä¸­çš„ç‰©ä»¶
            saveToLibraryBtn.disabled = count !== 1;

            // å¦‚æœåªé¸äº†ä¸€å€‹ï¼Œè¼‰å…¥å…¶å±¬æ€§åˆ°è¡¨å–®
            if (count === 1) {
                const item = selectedItems[0];
                const isRoom = item.classList.contains('room');
                
                if (isRoom) {
                    document.getElementById('roomWidth').value = item.dataset.cmWidth;
                    document.getElementById('roomHeight').value = item.dataset.cmHeight;
                    document.getElementById('roomLabel').value = item.dataset.label;
                    document.getElementById('roomFontSize').value = item.dataset.fontSize || 14;
                    document.getElementById('roomRotation').value = item.dataset.rotation || 0;
                } else { // is Furniture
                    document.getElementById('furnWidth').value = item.dataset.cmWidth;
                    document.getElementById('furnHeight').value = item.dataset.cmHeight;
                    document.getElementById('furnLabel').value = item.dataset.label;
                    document.getElementById('furnColor').value = item.dataset.colorHex;
                    document.getElementById('furnShape').value = item.style.borderRadius === '50%' ? 'circle' : 'rectangle';
                    document.getElementById('furnFontSize').value = item.dataset.fontSize || 14;
                    document.getElementById('furnRotation').value = item.dataset.rotation || 0;
                    const opacity = (item.dataset.opacity || 1) * 100;
                    opacitySlider.value = opacity;
                    opacityValue.innerText = Math.round(opacity);
                }
            }
        }

        // D-5: é»æ“Š/è§¸æ§ç•«å¸ƒèƒŒæ™¯ -> é–‹å§‹æ‹–æ›³é¸æ¡† æˆ– å–æ¶ˆé¸å–
        canvasWrapper.addEventListener('mousedown', startSelectionOrPan);
        canvasWrapper.addEventListener('touchstart', startSelectionOrPan, { passive: false });

        function startSelectionOrPan(e) {
            // å¦‚æœé»æ“Šçš„æ˜¯ç‰©ä»¶ï¼Œå¿½ç•¥ (ç”±ç‰©ä»¶è‡ªå·±çš„äº‹ä»¶è™•ç†)
            if (e.target !== canvasWrapper && e.target !== canvas) return;
             // å¦‚æœæŒ‰è‘— Shift éµï¼Œå¿½ç•¥ (ä¿ç•™ç¾æœ‰é¸å–)
            if (e.shiftKey) return;

            const { x, y } = getEventCoords(e);
            
            if (isPanMode) {
                // é–‹å§‹å¹³ç§»
                canvasWrapper.style.cursor = 'grabbing';
                panStartX = x;
                panStartY = y;
                scrollStartX = canvasWrapper.scrollLeft;
                scrollStartY = canvasWrapper.scrollTop;
                document.addEventListener('mousemove', panCanvas);
                document.addEventListener('mouseup', endPan);
                document.addEventListener('touchmove', panCanvas, { passive: false });
                document.addEventListener('touchend', endPan);
            } else {
                // é–‹å§‹æ‹–æ›³é¸æ¡†
                isSelectingBox = true;
                const canvasRect = canvasWrapper.getBoundingClientRect(); // ç›¸å°æ–¼ viewport
                selectionStartX = x - canvasRect.left + canvasWrapper.scrollLeft;
                selectionStartY = y - canvasRect.top + canvasWrapper.scrollTop;

                selectionBox.style.left = selectionStartX + 'px';
                selectionBox.style.top = selectionStartY + 'px';
                selectionBox.style.width = '0px';
                selectionBox.style.height = '0px';
                selectionBox.style.display = 'block';

                document.addEventListener('mousemove', dragSelectionBox);
                document.addEventListener('mouseup', endSelectionBox);
                document.addEventListener('touchmove', dragSelectionBox, { passive: false });
                document.addEventListener('touchend', endSelectionBox);
                
                // æ¸…é™¤ä¹‹å‰çš„é¸å–
                clearSelection();
            }
        }
        
        // D-6: æ‹–æ›³é¸æ¡†ä¸­
        function dragSelectionBox(e) {
            if (!isSelectingBox) return;
            if (e.touches) e.preventDefault(); // é˜²æ»¾å‹•

            const { x, y } = getEventCoords(e);
            const canvasRect = canvasWrapper.getBoundingClientRect();
            const currentX = x - canvasRect.left + canvasWrapper.scrollLeft;
            const currentY = y - canvasRect.top + canvasWrapper.scrollTop;

            const left = Math.min(selectionStartX, currentX);
            const top = Math.min(selectionStartY, currentY);
            const width = Math.abs(selectionStartX - currentX);
            const height = Math.abs(selectionStartY - currentY);

            selectionBox.style.left = left + 'px';
            selectionBox.style.top = top + 'px';
            selectionBox.style.width = width + 'px';
            selectionBox.style.height = height + 'px';
        }

        // D-7: æ‹–æ›³é¸æ¡†çµæŸ
        function endSelectionBox(e) {
            if (!isSelectingBox) return;
            isSelectingBox = false;
            selectionBox.style.display = 'none';

            document.removeEventListener('mousemove', dragSelectionBox);
            document.removeEventListener('mouseup', endSelectionBox);
            document.removeEventListener('touchmove', dragSelectionBox);
            document.removeEventListener('touchend', endSelectionBox);

            // è¨ˆç®—é¸æ¡†ç¯„åœ (è€ƒæ…®ç¸®æ”¾)
            const boxLeft = parseFloat(selectionBox.style.left) / zoomLevel;
            const boxTop = parseFloat(selectionBox.style.top) / zoomLevel;
            const boxWidth = parseFloat(selectionBox.style.width) / zoomLevel;
            const boxHeight = parseFloat(selectionBox.style.height) / zoomLevel;
            const boxRight = boxLeft + boxWidth;
            const boxBottom = boxTop + boxHeight;

            // æ‰¾å‡ºæ‰€æœ‰èˆ‡é¸æ¡†é‡ç–Šçš„ç‰©ä»¶
            const itemsInBox = [];
            const allItems = canvas.querySelectorAll('.room, .furniture');
            allItems.forEach(item => {
                const itemLeft = item.offsetLeft;
                const itemTop = item.offsetTop;
                // ç°¡åŒ–åˆ¤æ–·ï¼šåªæª¢æŸ¥ç‰©ä»¶ä¸­å¿ƒé»æ˜¯å¦åœ¨æ¡†å…§
                const itemCenterX = itemLeft + item.offsetWidth / 2;
                const itemCenterY = itemTop + item.offsetHeight / 2;
                
                if (itemCenterX >= boxLeft && itemCenterX <= boxRight &&
                    itemCenterY >= boxTop && itemCenterY <= boxBottom) {
                    itemsInBox.push(item);
                }
            });

            if (itemsInBox.length > 0) {
                setSelection(itemsInBox);
            }
        }


        // --- åŠŸèƒ½ E: ç·¨è¼¯ / åˆªé™¤ ---
        const updateBtn = document.getElementById('updateBtn');
        const deleteBtn = document.getElementById('deleteBtn');

        // E-1: åˆªé™¤ (å¤šé¸)
        deleteBtn.onclick = function() {
            if (selectedItems.length === 0) {
                 alert('è«‹å…ˆé¸å–è¦åˆªé™¤çš„é …ç›®ã€‚');
                 return;
            }
            if (confirm(`ç¢ºå®šè¦åˆªé™¤é¸å–çš„ ${selectedItems.length} å€‹é …ç›®å—ï¼Ÿ`)) {
                saveStateForUndo("Delete Selected"); 
                selectedItems.forEach(item => item.remove());
                clearSelection(); // æ¸…ç©ºé¸å–
            }
        };

        // E-2: æ›´æ–° (åƒ…é™å–®é¸)
        updateBtn.onclick = function() {
            if (selectedItems.length !== 1) {
                 alert('è«‹åªé¸å–ä¸€å€‹é …ç›®ä¾†æ›´æ–°å±¬æ€§ã€‚');
                 return;
            }
            saveStateForUndo("Update Item");
            
            const item = selectedItems[0];
            const isRoom = item.classList.contains('room');

            try {
                if (isRoom) {
                    const width = document.getElementById('roomWidth').value, height = document.getElementById('roomHeight').value;
                    const label = document.getElementById('roomLabel').value;
                    const fontSize = document.getElementById('roomFontSize').value;
                    const rotation = document.getElementById('roomRotation').value;

                    item.dataset.cmWidth = width; item.dataset.cmHeight = height;
                    item.dataset.label = label; item.dataset.fontSize = fontSize;
                    item.dataset.rotation = rotation;

                    item.style.width = (width * SCALE) + 'px'; item.style.height = (height * SCALE) + 'px';
                    item.style.setProperty('--font-size', fontSize + 'px');
                    item.style.transform = 'rotate(' + rotation + 'deg)';
                    updateElementLabels(item, 'room', label, width, height);
                } else { // Furniture
                    const width = document.getElementById('furnWidth').value, height = document.getElementById('furnHeight').value;
                    const label = document.getElementById('furnLabel').value, color = document.getElementById('furnColor').value;
                    const shape = document.getElementById('furnShape').value, opacity = opacitySlider.value / 100;
                    const fontSize = document.getElementById('furnFontSize').value;
                    const rotation = document.getElementById('furnRotation').value;
                    
                    item.dataset.cmWidth = width; item.dataset.cmHeight = height;
                    item.dataset.label = label; item.dataset.colorHex = color;
                    item.dataset.opacity = opacity; item.dataset.fontSize = fontSize;
                    item.dataset.rotation = rotation;
                    
                    item.style.width = (width * SCALE) + 'px'; item.style.height = (height * SCALE) + 'px';
                    item.style.borderRadius = (shape === 'circle') ? '50%' : '0';
                    item.style.setProperty('--font-size', fontSize + 'px');
                    item.style.transform = 'rotate(' + rotation + 'deg)';
                    const rgb = hexToRgb(color);
                    item.style.backgroundColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                    updateElementLabels(item, 'furniture', label, width, height);
                }
                alert('é …ç›®å·²æ›´æ–°ï¼');
            } catch (e) { 
                alert('æ›´æ–°å¤±æ•—: ' + e.message); 
                // å¦‚æœæ›´æ–°å¤±æ•—ï¼Œå¾©åŸåˆ°ä¸Šä¸€æ­¥
                if (historyStack.length > 0) loadLayout(historyStack.pop());
                updateUndoRedoButtons();
            }
        };

        // --- (æ–°) åŠŸèƒ½ F: åœ–å±¤ç®¡ç† ---
        bringForwardBtn.onclick = () => changeLayer(1);
        sendBackwardBtn.onclick = () => changeLayer(-1);
        bringToFrontBtn.onclick = () => changeLayer(Infinity);
        sendToBackBtn.onclick = () => changeLayer(-Infinity);

        function changeLayer(delta) {
            if (selectedItems.length !== 1) return;
            const item = selectedItems[0];
            const currentZ = parseInt(item.style.zIndex || (item.classList.contains('room') ? Z_INDEX_ROOM_BASE : Z_INDEX_FURN_BASE));
            let newZ;

            saveStateForUndo("Change Layer");

            if (delta === Infinity) { // ç½®é ‚
                // æ‰¾åˆ°ç•«å¸ƒä¸Šç›®å‰æœ€é«˜çš„ z-index å†åŠ  1
                let maxZ = item.classList.contains('room') ? Z_INDEX_ROOM_BASE : Z_INDEX_FURN_BASE;
                canvas.querySelectorAll('.room, .furniture').forEach(el => {
                    const z = parseInt(el.style.zIndex);
                    if (!isNaN(z) && z > maxZ) maxZ = z;
                });
                newZ = maxZ + Z_INDEX_STEP;
            } else if (delta === -Infinity) { // ç½®åº•
                newZ = item.classList.contains('room') ? Z_INDEX_ROOM_BASE : Z_INDEX_FURN_BASE;
            } else { // ä¸Šç§»/ä¸‹ç§»
                newZ = currentZ + delta * Z_INDEX_STEP;
                // ç¢ºä¿ä¸ä½æ–¼åŸºç¤å€¼
                if (item.classList.contains('room')) {
                    newZ = Math.max(Z_INDEX_ROOM_BASE, newZ);
                } else {
                    newZ = Math.max(Z_INDEX_FURN_BASE, newZ);
                }
            }
            item.style.zIndex = newZ;
        }

        // --- (æ–°) åŠŸèƒ½ G: ç¾¤çµ„ ---
        groupBtn.onclick = function() {
            if (selectedItems.length < 2) return;
            saveStateForUndo("Group Items");
            const groupId = `group-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;
            selectedItems.forEach(item => {
                item.dataset.groupId = groupId;
            });
            // ç¾¤çµ„å¾Œä¿æŒé¸å–ç‹€æ…‹
            updateSelectionUI(); 
            alert(`å·²å°‡ ${selectedItems.length} å€‹é …ç›®è¨­ç‚ºç¾¤çµ„ï¼`);
        }

        ungroupBtn.onclick = function() {
            const itemsToUngroup = selectedItems.filter(item => item.dataset.groupId);
            if (itemsToUngroup.length === 0) return;
            saveStateForUndo("Ungroup Items");
            itemsToUngroup.forEach(item => {
                delete item.dataset.groupId;
            });
            // è§£æ•£ç¾¤çµ„å¾Œä¿æŒé¸å–ç‹€æ…‹
            updateSelectionUI();
             alert(`å·²å°‡ ${itemsToUngroup.length} å€‹é …ç›®å–æ¶ˆç¾¤çµ„ï¼`);
        }
        
        // --- (æ–°) åŠŸèƒ½ H: å¹³ç§»æ¨¡å¼ ---
        const panModeBtn = document.getElementById('panModeBtn');
        panModeBtn.onclick = function() {
            isPanMode = !isPanMode;
            if (isPanMode) {
                panModeBtn.textContent = 'é¸å–æ¨¡å¼ (ğŸ‘†)';
                panModeBtn.classList.add('info');
                panModeBtn.classList.remove('secondary');
                canvasWrapper.classList.add('pan-mode');
                clearSelection(); // é€²å…¥å¹³ç§»æ¨¡å¼æ™‚å–æ¶ˆé¸å–
            } else {
                panModeBtn.textContent = 'å¹³ç§»æ¨¡å¼ (ğŸ–ï¸)';
                panModeBtn.classList.add('secondary');
                panModeBtn.classList.remove('info');
                canvasWrapper.classList.remove('pan-mode');
            }
        }

        function panCanvas(e) {
            if (!isPanMode) return;
            if (e.touches) e.preventDefault(); // é˜»æ­¢é é¢æ»¾å‹•

            const { x, y } = getEventCoords(e);
            const dx = x - panStartX;
            const dy = y - panStartY;
            
            canvasWrapper.scrollLeft = scrollStartX - dx;
            canvasWrapper.scrollTop = scrollStartY - dy;
        }

        function endPan(e) {
            if (!isPanMode) return;
            canvasWrapper.style.cursor = 'grab'; // æ¢å¾©æ¸¸æ¨™
            document.removeEventListener('mousemove', panCanvas);
            document.removeEventListener('mouseup', endPan);
            document.removeEventListener('touchmove', panCanvas);
            document.removeEventListener('touchend', endPan);
        }

        // --- (æ–°) åŠŸèƒ½ I: ç‰©ä»¶åº« ---
        const saveToLibraryBtn = document.getElementById('saveToLibraryBtn');
        const libraryItemsContainer = document.getElementById('libraryItems');
        let objectLibrary = JSON.parse(localStorage.getItem('objectLibrary') || '[]');

        // I-1: æ¸²æŸ“ç‰©ä»¶åº«
        function renderLibrary() {
            libraryItemsContainer.innerHTML = '';
            objectLibrary.forEach((itemData, index) => {
                const itemWrapper = document.createElement('div');
                itemWrapper.className = 'library-item';
                itemWrapper.title = itemData.label;

                const preview = document.createElement('div');
                preview.className = 'library-item-preview';
                
                // æ‡‰ç”¨æ¨£å¼
                const isRoom = !itemData.color; // ç°¡å–®åˆ¤æ–·æ˜¯å¦ç‚ºæˆ¿é–“
                if (isRoom) {
                     preview.style.backgroundColor = '#fff';
                     preview.style.border = '2px solid #ccc';
                } else {
                    const rgb = hexToRgb(itemData.color);
                    const opacity = itemData.opacity || 1;
                    preview.style.backgroundColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                    if (itemData.shape === 'circle') preview.style.borderRadius = '50%';
                }
                // é è¦½ä¸é¡¯ç¤ºæ–‡å­—ï¼Œåªé¡¯ç¤ºå½¢ç‹€å’Œé¡è‰²
                // preview.style.transform = `rotate(${itemData.rotation || 0}deg)`; // é è¦½æ˜¯å¦è¦æ—‹è½‰? å…ˆä¸è¦

                const label = document.createElement('span');
                label.className = 'library-item-label';
                label.textContent = itemData.label;
                
                // (æ–°) åˆªé™¤æŒ‰éˆ•
                const deleteButton = document.createElement('button');
                deleteButton.className = 'delete-lib-item';
                deleteButton.innerHTML = '&times;';
                deleteButton.title = 'å¾åº«ä¸­åˆªé™¤';
                deleteButton.onclick = (e) => {
                    e.stopPropagation(); // é˜²æ­¢è§¸ç™¼æ–°å¢
                    if (confirm(`ç¢ºå®šè¦å¾ç‰©ä»¶åº«åˆªé™¤ "${itemData.label}" å—ï¼Ÿ`)) {
                        deleteFromLibrary(index);
                    }
                };

                itemWrapper.appendChild(preview);
                itemWrapper.appendChild(label);
                itemWrapper.appendChild(deleteButton);

                // é»æ“Šæ–°å¢
                itemWrapper.onclick = () => {
                    addItemFromLibrary(itemData);
                };
                
                libraryItemsContainer.appendChild(itemWrapper);
            });
        }

        // I-2: å„²å­˜é¸ä¸­è‡³åº«
        saveToLibraryBtn.onclick = function() {
            if (selectedItems.length !== 1) return;
            const item = selectedItems[0];
            const isRoom = item.classList.contains('room');
            
            const itemData = {
                cmWidth: item.dataset.cmWidth, cmHeight: item.dataset.cmHeight,
                label: item.dataset.label, fontSize: item.dataset.fontSize,
                rotation: item.dataset.rotation
            };
            
            if (!isRoom) {
                itemData.color = item.dataset.colorHex;
                itemData.opacity = item.dataset.opacity;
                itemData.shape = item.style.borderRadius === '50%' ? 'circle' : 'rectangle';
            }
            
            // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨ (ç°¡æ˜“åˆ¤æ–·)
            const exists = objectLibrary.some(libItem => libItem.label === itemData.label && libItem.cmWidth === itemData.cmWidth && libItem.cmHeight === itemData.cmHeight);
            
            if (exists) {
                if (!confirm(`ç‰©ä»¶ "${itemData.label}" å·²å­˜åœ¨åº«ä¸­ï¼Œæ˜¯å¦è¦†è“‹ï¼Ÿ`)) {
                    return;
                }
                // è¦†è“‹: å…ˆåˆªé™¤èˆŠçš„
                objectLibrary = objectLibrary.filter(libItem => !(libItem.label === itemData.label && libItem.cmWidth === itemData.cmWidth && libItem.cmHeight === itemData.cmHeight));
            }

            objectLibrary.push(itemData);
            localStorage.setItem('objectLibrary', JSON.stringify(objectLibrary));
            renderLibrary();
            alert(`"${itemData.label}" å·²å„²å­˜è‡³ç‰©ä»¶åº«ï¼`);
        };

        // I-3: å¾åº«ä¸­æ–°å¢ç‰©ä»¶
        function addItemFromLibrary(itemData) {
            saveStateForUndo("Add Item from Library");
            
            let newItem;
            const isRoom = !itemData.color;
            const positionX = (canvasWrapper.scrollLeft + canvasWrapper.offsetWidth / 2) / zoomLevel; // ç•«é¢ä¸­å¤®
            const positionY = (canvasWrapper.scrollTop + canvasWrapper.offsetHeight / 2) / zoomLevel;

            if (isRoom) {
                newItem = createRoomElement(itemData.cmWidth, itemData.cmHeight, itemData.label, itemData.fontSize, itemData.rotation);
            } else {
                newItem = createFurnitureElement(itemData.cmWidth, itemData.cmHeight, itemData.shape, itemData.color, itemData.label, itemData.opacity, itemData.fontSize, itemData.rotation);
            }

            newItem.style.left = positionX - newItem.offsetWidth / 2 + 'px'; // æ”¾åˆ°ä¸­å¤®
            newItem.style.top = positionY - newItem.offsetHeight / 2 + 'px';
            
            canvas.appendChild(newItem);
            makeDraggable(newItem); // ç¶å®šæ‹–æ›³
            
            // ç¶å®šé¸å–
            newItem.addEventListener('click', (e) => { e.stopPropagation(); toggleSelection(newItem, e.shiftKey); });
            newItem.addEventListener('touchstart', (e) => { e.stopPropagation(); toggleSelection(newItem, false); }); // è§¸æ§ä¸æ”¯æ´ Shift

            setSelection(newItem); // æ–°å¢å¾Œè‡ªå‹•é¸å–
        }
        
        // (æ–°) I-4: å¾åº«ä¸­åˆªé™¤
        function deleteFromLibrary(index) {
             objectLibrary.splice(index, 1);
             localStorage.setItem('objectLibrary', JSON.stringify(objectLibrary));
             renderLibrary();
        }

        // --- åŠŸèƒ½ J: æ–°å¢é …ç›® ---

        // J-1: æ–°å¢æˆ¿é–“
        addRoomBtn.onclick = function() {
            saveStateForUndo("Add Room"); 
            const roomWidth = document.getElementById('roomWidth').value, roomHeight = document.getElementById('roomHeight').value;
            const roomLabel = document.getElementById('roomLabel').value;
            const roomFontSize = document.getElementById('roomFontSize').value;
            const roomRotation = document.getElementById('roomRotation').value;

            const room = createRoomElement(roomWidth, roomHeight, roomLabel, roomFontSize, roomRotation);
            room.style.left = (canvasWrapper.scrollLeft + 50) / zoomLevel + 'px';
            room.style.top = (canvasWrapper.scrollTop + 50) / zoomLevel + 'px';
            makeDraggable(room);
            
            room.addEventListener('click', (e) => { e.stopPropagation(); toggleSelection(room, e.shiftKey); });
            room.addEventListener('touchstart', (e) => { e.stopPropagation(); toggleSelection(room, false); });
            
            canvas.appendChild(room);
            setSelection(room);
        };

        // J-2: æ–°å¢å®¶å…·
        addFurnitureBtn.onclick = function() {
            saveStateForUndo("Add Furniture"); 
            const width = document.getElementById('furnWidth').value, height = document.getElementById('furnHeight').value;
            const shape = document.getElementById('furnShape').value, color = document.getElementById('furnColor').value;
            const label = document.getElementById('furnLabel').value, opacity = opacitySlider.value / 100;
            const fontSize = document.getElementById('furnFontSize').value;
            const rotation = document.getElementById('furnRotation').value;
            
            const furniture = createFurnitureElement(width, height, shape, color, label, opacity, fontSize, rotation);
            furniture.style.left = (canvasWrapper.scrollLeft + 50) / zoomLevel + 'px';
            furniture.style.top = (canvasWrapper.scrollTop + 50) / zoomLevel + 'px';
            
            canvas.appendChild(furniture);
            makeDraggable(furniture);
            
            furniture.addEventListener('click', (e) => { e.stopPropagation(); toggleSelection(furniture, e.shiftKey); });
            furniture.addEventListener('touchstart', (e) => { e.stopPropagation(); toggleSelection(furniture, false); });
            
            setSelection(furniture);
        };
        
        // --- è¼”åŠ©åŠŸèƒ½ï¼šå»ºç«‹å…ƒç´  DOM ---

        // K-1: å»ºç«‹æˆ¿é–“
        function createRoomElement(width, height, label, fontSize = 14, rotation = 0, id = null) {
            const room = document.createElement('div');
            room.className = 'room';
            room.dataset.id = id || `room-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`; // (æ–°) ID
            room.dataset.cmWidth = width; room.dataset.cmHeight = height;
            room.dataset.label = label; room.dataset.fontSize = fontSize;
            room.dataset.rotation = rotation;
            room.style.width = (width * SCALE) + 'px'; room.style.height = (height * SCALE) + 'px';
            room.style.setProperty('--font-size', fontSize + 'px');
            room.style.transform = 'rotate(' + rotation + 'deg)';
            room.style.zIndex = Z_INDEX_ROOM_BASE; // (æ–°)
            updateElementLabels(room, 'room', label, width, height);
            return room;
        }

        // K-2: å»ºç«‹å®¶å…·
        function createFurnitureElement(width, height, shape, color, label, opacity = 1, fontSize = 14, rotation = 0, id = null) {
            const furniture = document.createElement('div');
            furniture.className = 'furniture';
            furniture.dataset.id = id || `furn-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`; // (æ–°) ID
            furniture.dataset.cmWidth = width; furniture.dataset.cmHeight = height;
            furniture.dataset.label = label; furniture.dataset.colorHex = color;
            furniture.dataset.opacity = opacity; furniture.dataset.fontSize = fontSize;
            furniture.dataset.rotation = rotation;
            
            furniture.style.width = (width * SCALE) + 'px'; furniture.style.height = (height * SCALE) + 'px';
            furniture.style.setProperty('--font-size', fontSize + 'px');
            furniture.style.transform = 'rotate(' + rotation + 'deg)';
            furniture.style.zIndex = Z_INDEX_FURN_BASE; // (æ–°)
            
            const rgb = hexToRgb(color);
            furniture.style.backgroundColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
            if (shape === 'circle') furniture.style.borderRadius = '50%';
            updateElementLabels(furniture, 'furniture', label, width, height);
            return furniture;
        }
        
        // K-3: æ›´æ–°å…ƒç´ æ¨™ç±¤
        function updateElementLabels(element, type, label, width, height) {
            element.innerHTML = '';
            const prefix = (type === 'room') ? 'room-' : '';
            const mainClass = (type === 'room') ? 'label-room-main' : 'label-main';
            const widthClass = (type === 'room') ? 'label-room-width' : 'label-width';
            const heightClass = (type === 'room') ? 'label-room-height' : 'label-height';

            const labelMain = document.createElement('span');
            labelMain.className = `${prefix}label ${mainClass}`;
            labelMain.innerText = label;
            
            const labelWidth = document.createElement('span');
            labelWidth.className = `${prefix}label ${widthClass}`;
            labelWidth.innerText = `${width} cm`;
            
            const labelHeight = document.createElement('span');
            labelHeight.className = `${prefix}label ${heightClass}`;
            labelHeight.innerText = `${height} cm`;
            
            element.appendChild(labelMain);
            element.appendChild(labelWidth);
            element.appendChild(labelHeight);
        }

        
        // --- (*** é‡æ§‹ ***) åŠŸèƒ½ L: çµ±ä¸€çš„æ‹–æ›³å‡½å¼ (æ”¯æ´å¤šé¸/ç¾¤çµ„/æ—‹è½‰å„ªåŒ–) ---
        function makeDraggable(element) {
            let isDragging = false;
            let currentDragTargets = []; // (æ–°) å¯èƒ½æ‹–æ›³å–®ä¸€æˆ–å¤šå€‹ (ç¾¤çµ„/å¤šé¸)
            let dragStartPositions = []; // (æ–°) å„²å­˜æ¯å€‹ç‰©ä»¶çš„åˆå§‹ä½ç½®
            let hasMoved = false;

            function onDragStart(e) {
                // (æ–°) å¹³ç§»æ¨¡å¼ä¸‹ç¦æ­¢æ‹–æ›³
                if (isPanMode) return;
                
                // (æ–°) é»æ“Šé¸å–é‚è¼¯
                if (!e.target.classList.contains('selected')) {
                    toggleSelection(e.target, e.shiftKey);
                }
                
                // (æ–°) å¦‚æœæ²’æœ‰é¸ä¸­çš„ç‰©ä»¶ï¼Œæˆ–é»æ“Šçš„ä¸æ˜¯é¸ä¸­çš„ç‰©ä»¶ (ä¸”æ²’æŒ‰ shift)ï¼Œå‰‡ä¸é–‹å§‹æ‹–æ›³
                if (selectedItems.length === 0 || !selectedItems.includes(e.target)) {
                    // å¦‚æœé»æ“Šç©ºç™½è™•ï¼Œæœƒç”± canvasWrapper çš„ mousedown è™•ç†
                    return;
                }

                e.stopPropagation(); 
                isDragging = true;
                hasMoved = false;
                stateBeforeDrag = getCurrentState();
                
                // (æ–°) è¨­å®šæ‹–æ›³ç›®æ¨™ (å¯èƒ½æ˜¯å¤šå€‹)
                currentDragTargets = [...selectedItems]; // è¤‡è£½ä¸€ä»½ï¼Œé¿å…é¸å–è®ŠåŒ–å½±éŸ¿
                dragStartPositions = currentDragTargets.map(item => ({
                    element: item,
                    startX: item.offsetLeft,
                    startY: item.offsetTop
                }));

                const { x, y } = getEventCoords(e);
                const canvasRect = canvas.getBoundingClientRect();
                
                // (æ–°) è¨ˆç®—æ»‘é¼ ç›¸å°æ–¼ Canvas çš„é»æ“Šä½ç½®
                const pointerStartX = (x / zoomLevel) - (canvasRect.left / zoomLevel);
                const pointerStartY = (y / zoomLevel) - (canvasRect.top / zoomLevel);

                // (æ–°) è¨ˆç®—æ»‘é¼ ç›¸å°æ–¼ã€Œè¢«é»æ“Šå…ƒç´ ã€å·¦ä¸Šè§’çš„åç§»
                // æ³¨æ„ï¼šé€™è£¡ç”¨çš„æ˜¯è¢«é»æ“Šçš„ e.targetï¼Œè€Œä¸æ˜¯ group center
                dragOffsetX = pointerStartX - e.target.offsetLeft;
                dragOffsetY = pointerStartY - e.target.offsetTop;
                
                currentDragTargets.forEach(item => {
                    item.style.zIndex = parseInt(item.style.zIndex || (item.classList.contains('room') ? Z_INDEX_ROOM_BASE : Z_INDEX_FURN_BASE)) + 1000; // æé«˜ z-index
                    item.style.transition = 'none'; // ç§»é™¤å‹•ç•«
                });
                
                document.addEventListener('mousemove', onDragMove);
                document.addEventListener('mouseup', onDragEnd);
                document.addEventListener('touchmove', onDragMove, { passive: false });
                document.addEventListener('touchend', onDragEnd);
            }

            function onDragMove(e) {
                if (!isDragging) return;
                if (e.touches) e.preventDefault();
                hasMoved = true;
                
                const { x, y } = getEventCoords(e);
                const canvasRect = canvas.getBoundingClientRect();
                
                const pointerX = (x / zoomLevel) - (canvasRect.left / zoomLevel);
                const pointerY = (y / zoomLevel) - (canvasRect.top / zoomLevel);
                
                // (æ–°) è¨ˆç®—è¢«é»æ“Šå…ƒç´ çš„ç›®æ¨™æ–°ä½ç½®
                const targetNewX = pointerX - dragOffsetX;
                const targetNewY = pointerY - dragOffsetY;
                
                // (æ–°) è¨ˆç®—ç›¸å°æ–¼æ‹–æ›³é–‹å§‹æ™‚çš„ä½ç§»é‡
                const dx = targetNewX - dragStartPositions[0].element.offsetLeft;
                const dy = targetNewY - dragStartPositions[0].element.offsetTop;

                // (æ–°) å°‡ä½ç§»é‡æ‡‰ç”¨åˆ°æ‰€æœ‰æ‹–æ›³ç›®æ¨™ä¸Š
                dragStartPositions.forEach((startPos, index) => {
                    const item = startPos.element;
                    let itemNewX = startPos.startX + dx;
                    let itemNewY = startPos.startY + dy;

                    // --- å¸é™„èˆ‡ç¢°æ’ (åªå°ç¬¬ä¸€å€‹æ‹–æ›³ç‰©ä»¶é€²è¡Œè¨ˆç®—å’Œæ‡‰ç”¨) ---
                    // (é€™æ˜¯ä¸€å€‹ç°¡åŒ–ï¼Œç†æƒ³æƒ…æ³ä¸‹æ‡‰è©²å°æ¯å€‹ç‰©ä»¶ç¨ç«‹è¨ˆç®—ï¼Œä½†éå¸¸è¤‡é›œ)
                    if (index === 0) {
                        const elemWidth = item.clientWidth;
                        const elemHeight = item.clientHeight;
                        const rotation = parseFloat(item.dataset.rotation) || 0;
                        const isAxisAligned = (rotation % 90 === 0);
                        let effectiveWidth = elemWidth, effectiveHeight = elemHeight;
                        if (isAxisAligned && (rotation % 180 !== 0)) {
                            effectiveWidth = elemHeight; effectiveHeight = elemWidth;
                        }
                        
                        // å¸é™„ (åƒ…è»¸å°é½Š)
                        if (document.getElementById('enableSnapping').checked && isAxisAligned) {
                            let snappedX = false, snappedY = false;
                            const myLeft = itemNewX, myRight = itemNewX + effectiveWidth, myTop = itemNewY, myBottom = itemNewY + effectiveHeight;
                            
                            // å¸é™„å…¶ä»–æœªè¢«æ‹–æ›³çš„ç‰©ä»¶ + æ‰€æœ‰æˆ¿é–“
                            const otherItems = Array.from(canvas.querySelectorAll('.room, .furniture')).filter(el => !currentDragTargets.includes(el));
                            
                            for (const other of otherItems) {
                                const oLeft = other.offsetLeft, oRight = oLeft + other.clientWidth, oTop = other.offsetTop, oBottom = oTop + other.clientHeight;
                                // ç°¡æ˜“å¸é™„ï¼Œåªè€ƒæ…®å·¦ä¸Šè§’
                                if (!snappedX) {
                                    if (Math.abs(myLeft - oRight) < SNAP_DISTANCE) { itemNewX = oRight; snappedX = true; }
                                    else if (Math.abs(myRight - oLeft) < SNAP_DISTANCE) { itemNewX = oLeft - effectiveWidth; snappedX = true; }
                                    // ... å¯ä»¥åŠ å…¥æ›´å¤šå¸é™„é»çš„åˆ¤æ–·
                                }
                                if (!snappedY) {
                                     if (Math.abs(myTop - oBottom) < SNAP_DISTANCE) { itemNewY = oBottom; snappedY = true; }
                                     else if (Math.abs(myBottom - oTop) < SNAP_DISTANCE) { itemNewY = oTop - effectiveHeight; snappedY = true; }
                                     // ...
                                }
                                if (snappedX && snappedY) break;
                            }
                            // æ›´æ–°ä½ç§»é‡ï¼Œè®“å…¶ä»–ç‰©ä»¶è·Ÿéš¨
                            dx = itemNewX - startPos.startX;
                            dy = itemNewY - startPos.startY;
                        }

                        // ç¢°æ’ (åƒ…è»¸å°é½Šï¼Œä¸”åªæª¢æŸ¥ç¬¬ä¸€å€‹ç‰©ä»¶)
                        let isColliding = false;
                        if (document.getElementById('preventOverlap').checked && isAxisAligned) {
                            const otherFurn = Array.from(canvas.querySelectorAll('.furniture')).filter(el => !currentDragTargets.includes(el));
                            for (const sibling of otherFurn) {
                                const sRect = { left: sibling.offsetLeft, top: sibling.offsetTop, right: sibling.offsetLeft + sibling.clientWidth, bottom: sibling.offsetTop + sibling.clientHeight };
                                const eRect = { left: itemNewX, top: itemNewY, right: itemNewX + effectiveWidth, bottom: itemNewY + effectiveHeight };
                                if (eRect.left < sRect.right && eRect.right > sRect.left && eRect.top < sRect.bottom && eRect.bottom > sRect.top) {
                                    isColliding = true; break;
                                }
                            }
                        }
                        
                        // æ›´æ–°ç¢°æ’æ¨£å¼ (åªå°ç¬¬ä¸€å€‹ç‰©ä»¶)
                        if (isColliding) { item.classList.add('colliding'); } 
                        else { item.classList.remove('colliding'); }
                        
                        // æ›´æ–°æ‰€æœ‰æ‹–æ›³ç‰©ä»¶çš„ä½ç½® (åŸºæ–¼ç¬¬ä¸€å€‹ç‰©ä»¶è¨ˆç®—å‡ºçš„ dx, dy)
                        currentDragTargets.forEach((target, i) => {
                             target.style.left = dragStartPositions[i].startX + dx + 'px';
                             target.style.top = dragStartPositions[i].startY + dy + 'px';
                             if (!isColliding) { // åªæœ‰æ²’ç¢°æ’æ‰æ›´æ–°æœ‰æ•ˆä½ç½®
                                 target.dataset.lastValidX = dragStartPositions[i].startX + dx;
                                 target.dataset.lastValidY = dragStartPositions[i].startY + dy;
                             }
                        });
                        
                    } // end if (index === 0)
                    
                }); // end dragStartPositions.forEach
            } // end onDragMove

            function onDragEnd(e) {
                if (!isDragging) return;
                isDragging = false;

                if (hasMoved && stateBeforeDrag) {
                    // æª¢æŸ¥æ˜¯å¦æœ‰ç¢°æ’ï¼Œå¦‚æœæœ‰ï¼Œå‰‡é‚„åŸ
                    const collisionHappened = currentDragTargets.some(item => item.classList.contains('colliding'));
                    
                    if (collisionHappened && document.getElementById('preventOverlap').checked) {
                         // é‚„åŸä½ç½®
                         currentDragTargets.forEach((item, i) => {
                            item.style.left = dragStartPositions[i].startX + 'px';
                            item.style.top = dragStartPositions[i].startY + 'px';
                            item.classList.remove('colliding');
                         });
                         // ä¸¦ä¸”ä¸å„²å­˜æ­·å²ç´€éŒ„ï¼Œå› ç‚ºæ˜¯ç„¡æ•ˆç§»å‹•
                         stateBeforeDrag = null; 
                    } else {
                        // å„²å­˜æ‹–æ›³å¾Œçš„ç‹€æ…‹
                        redoStack = [];
                        historyStack.push(stateBeforeDrag);
                        updateUndoRedoButtons();
                    }
                }
                stateBeforeDrag = null;

                currentDragTargets.forEach(item => {
                    const baseZ = item.classList.contains('room') ? Z_INDEX_ROOM_BASE : Z_INDEX_FURN_BASE;
                    item.style.zIndex = parseInt(item.style.zIndex) - 1000; // æ¢å¾© z-index
                    item.style.transition = 'left 0.1s ease-out, top 0.1s ease-out, background-color 0.2s, transform 0.2s, box-shadow 0.2s';
                    item.classList.remove('colliding'); // ç¢ºä¿ç§»é™¤
                });
                currentDragTargets = [];
                dragStartPositions = [];
                
                document.removeEventListener('mousemove', onDragMove);
                document.removeEventListener('mouseup', onDragEnd);
                document.removeEventListener('touchmove', onDragMove);
                document.removeEventListener('touchend', onDragEnd);
                
                // æ‹–æ›³çµæŸå¾Œä¿æŒé¸å–
                updateSelectionUI(); 
            }
            
            element.addEventListener('mousedown', onDragStart);
            element.addEventListener('touchstart', onDragStart, { passive: false });
        }
        
        // --- åˆå§‹è¨­å®š ---
        renderLibrary(); // (æ–°) è¼‰å…¥ç‰©ä»¶åº«
        updateUndoRedoButtons();
        historyStack.push(getCurrentState()); // å„²å­˜ç©ºç™½çš„åˆå§‹ç‹€æ…‹

    </script>
</body>
</html>
