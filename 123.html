<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å®¤å…§ä½ˆå±€ç·¨è¼¯å™¨ (v14.0 - ä¿®æ­£æ¨™ç±¤ç¸®æ”¾/å°ºå¯¸)</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        /* --- åŸºæœ¬é é¢æ¨£å¼ --- */
        html, body { height: 100%; overflow: hidden; }
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f2f5;
            display: flex;
            height: 100vh;
        }

        /* å´é‚Šæ¬„æ”¶åˆæŒ‰éˆ• (ç„¡è®Šæ›´) */
        #toggleControlsBtn {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1001;
            background-color: #fff;
            border: 1px solid #ccc;
            border-left: none;
            width: 30px;
            height: 40px;
            padding: 0;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 2px 0 8px rgba(0,0,0,0.1);
            border-radius: 0 4px 4px 0;
            transition: transform 0.3s ease;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            line-height: 28px;
        }
        #toggleControlsBtn.collapsed {
            transform: translateX(-10px);
        }

        /* --- æ§åˆ¶é¢æ¿ (å·¦å´) --- */
        .controls {
            width: 300px;
            flex-shrink: 0;
            padding: 20px;
            background-color: #fff;
            box-shadow: 2px 0 8px rgba(0,0,0,0.1);
            overflow-y: auto;
            z-index: 100;
            height: 100vh;
            box-sizing: border-box;
            transition: width 0.3s ease, padding 0.3s ease, transform 0.3s ease;
            transform: translateX(0);
        }
        .controls.collapsed {
            width: 0;
            padding-left: 0;
            padding-right: 0;
            overflow: hidden;
            transform: translateX(-300px);
            box-shadow: none;
        }

        .controls h3 { margin-top: 20px; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        .controls h3:first-child { margin-top: 0; }

        /* å¯æ”¶åˆçš„ H3 æ¨™é¡Œ (ç„¡è®Šæ›´) */
        .controls h3.collapsible {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        .controls h3.collapsible:hover { background-color: #f9f9f9; }
        .toggle-section-btn {
            background: #e0e0e0;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            line-height: 24px;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            padding: 0;
            cursor: pointer;
        }
        /* å¯æ”¶åˆçš„å€å¡Š (ç„¡è®Šæ›´) */
        .controls-section {
            border:1px solid #eee; padding: 15px; border-radius: 5px; margin-top: 5px;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out, opacity 0.3s ease-out, border 0.3s ease-out;
            overflow: hidden;
            max-height: 1000px; /* é è¨­é«˜åº¦ */
            opacity: 1;
        }
        .controls-section.collapsed {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            opacity: 0;
            border: none;
            margin-top: 0;
        }


        .control-group { margin-bottom: 15px; }
        .controls label { display: block; margin-bottom: 5px; font-weight: bold; font-size: 14px; }
        .controls input[type="text"],
        .controls input[type="number"],
        .controls select,
        .controls textarea {
            width: calc(100% - 20px);
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }
        .controls select { font-family: Arial, sans-serif; font-size: 14px; }
        .controls input[type="text"],
        .controls input[type="number"] { font-family: Arial, sans-serif; font-size: 14px; }
        .controls input[type="range"] { width: 100%; padding: 0; }
        .controls input[type="color"] { padding: 0; height: 35px; width: 100%; }
        .controls button { width: 100%; padding: 10px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; transition: background-color 0.2s; margin-top: 5px; }
        .controls button:hover { background-color: #0056b3; }
        .controls button.secondary { background-color: #6c757d; }
        .controls button.secondary:hover { background-color: #5a6268; }
        .controls button.success { background-color: #28a745; }
        .controls button.success:hover { background-color: #218838; }
        .controls button.danger { background-color: #dc3545; }
        .controls button.danger:hover { background-color: #c82333; }
        .controls button.info { background-color: #17a2b8; }
        .controls button.info:hover { background-color: #138496; }
        .controls button.warning { background-color: #ffc107; color:#333; }
        .controls button.warning:hover { background-color: #e0a800; }
        .controls button:disabled,
        .controls button:disabled:hover { background-color: #c6c6c6; cursor: not-allowed; opacity: 0.6; }
        .control-row { display: flex; gap: 10px; }
        .control-row button { width: 100%; font-size: 14px; padding: 8px;} 
        .checkbox-group { display: flex; align-items: center; gap: 10px; }
        .checkbox-group label { margin-bottom: 0; font-weight: normal; }

        /* ç‰©ä»¶åº« (ç„¡è®Šæ›´) */
        #libraryItems { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 10px; margin-top: 10px; border-top: 1px solid #eee; padding-top: 10px; }
        .library-item { aspect-ratio: 1 / 1; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; position: relative; background-color: #f8f9fa; overflow: hidden; display: flex; align-items: center; justify-content: center; }
        .library-item:hover { background-color: #e9ecef; }
        .library-item-preview { width: 70%; height: 70%; border: 1px dashed #aaa; box-sizing: border-box; transform-origin: center; }
        .library-item-label { position: absolute; bottom: 2px; left: 0; width: 100%; text-align: center; font-size: 10px; color: #555; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .library-item button.delete-lib-item { position: absolute; top: 1px; right: 1px; width: 18px; height: 18px; line-height: 14px; padding: 0; font-size: 12px; background-color: rgba(220, 53, 69, 0.7); border: none; border-radius: 50%; color: white; cursor: pointer; z-index: 1; }

        /* --- æ¨¡æ“¬å€åŸŸ (å³å´) --- */
        #canvas-wrapper { flex-grow: 1; height: 100vh; overflow: auto; background-color: #e9ebee; -webkit-overflow-scrolling: touch; cursor: default; }
        #canvas-wrapper.pan-mode { cursor: grab; }
        #canvas-wrapper.pan-mode:active { cursor: grabbing; }
        #canvas { position: relative; width: 5000px; height: 5000px; background-color: #f8f9fa; background-image: linear-gradient(rgba(0,0,0,0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(0,0,0,0.05) 1px, transparent 1px); background-size: 20px 20px; transform-origin: top left; transition: transform 0.2s ease-out; }
        #selectionBox { position: absolute; border: 1px dashed #007bff; background-color: rgba(0, 123, 255, 0.1); pointer-events: none; z-index: 9999; display: none; }

        /* --- æˆ¿é–“ (ç•«å¸ƒ) --- */
        .room {
            position: absolute;
            background-color: #ffffff;
            border: 2px solid #aaa; 
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            box-sizing: border-box;
            transition: border-color 0.2s, transform 0.2s, box-shadow 0.2s;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            transform-origin: center;
            z-index: 50; 
            overflow: hidden;
        }
        .room:active { cursor: grabbing; }
        .room.selected { border: 3px solid #007bff; box-shadow: 0 0 15px rgba(0,123,255,0.3); z-index: 51; }

        /* æˆ¿é–“æ¨™ç±¤ (ç½®ä¸­, è‡ªå‹•ç¸®æ”¾) (ç„¡è®Šæ›´) */
        .room-label {
            position: relative;
            font-size: var(--font-size, 14px);
            font-weight: bold;
            color: rgba(0,0,0,0.25);
            pointer-events: none;
            user-select: none;
            white-space: nowrap;
            transition: font-size 0.1s;
        }

        /* --- å®¶å…· (è‰²å¡Š) --- */
        .furniture {
            position: absolute;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            border: 2px solid #555;
            transition: left 0.1s ease-out, top 0.1s ease-out, border-color 0.2s, background-color 0.2s, transform 0.2s, box-shadow 0.2s, clip-path 0.2s;
            z-index: 100; 
            transform-origin: center;
            overflow: hidden;
        }
        .furniture.selected { border: 3px solid #007bff; box-shadow: 0 0 15px rgba(0,123,255,0.3); z-index: 500; }

        /* å®¶å…·æ¨™ç±¤ (ç½®ä¸­, è‡ªå‹•ç¸®æ”¾) (ç„¡è®Šæ›´) */
        .furniture-label {
            position: relative;
            font-size: var(--font-size, 14px);
            color: #1f1f1f;
            text-shadow: 0 0 3px rgba(255,255,255,0.9);
            pointer-events: none;
            user-select: none;
            white-space: nowrap;
            font-weight: bold;
            transition: font-size 0.1s;
        }

        /* æ–‡å­—ç‰©ä»¶æ¨£å¼ (ç„¡è®Šæ›´) */
        .text-object {
            background-color: transparent !important;
            border: 1px dashed #999 !important;
        }
        .text-object .furniture-label {
            color: var(--text-color, #1f1f1f);
            text-shadow: none;
        }
        .text-object.selected {
             border: 3px dashed #007bff !important;
        }

        /* é–å®šç‹€æ…‹æ¨£å¼ (ç„¡è®Šæ›´) */
        .locked::after {
            content: 'ğŸ”’';
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: clamp(12px, 1.5vw, 16px);
            z-index: 1000;
            background: rgba(255,255,255,0.7);
            border-radius: 50%;
            padding: 2px;
            line-height: 1;
        }
        .locked {
            cursor: not-allowed !important;
        }

        /* Clip-path å½¢ç‹€ (ç„¡è®Šæ›´) */
        .furniture[data-shape="triangle-up"] { clip-path: polygon(50% 0%, 0% 100%, 100% 100%); }
        .furniture[data-shape="trapezoid-up"] { clip-path: polygon(20% 0%, 80% 0%, 100% 100%, 0% 100%); }


        .furniture.colliding { border: 3px solid #dc3545 !important; box-shadow: 0 0 10px rgba(220, 53, 69, 0.5); z-index: 1001 !important; transition: none; }

        /* --- æµ®å‹•å·¥å…·æ¬„ (ç„¡è®Šæ›´) --- */
        #floating-toolbar {
            position: absolute;
            background: #ffffff;
            border: 1px solid #ccc;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 10000;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 10px;
            transition: opacity 0.1s ease-out, transform 0.1s ease-out;
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
        }
        #floating-toolbar.visible { opacity: 1; transform: scale(1); pointer-events: auto; }
        .toolbar-group { display: flex; gap: 5px; align-items: center; flex-wrap: wrap; }
        .toolbar-group label { font-size: 12px; font-weight: bold; white-space: nowrap; }
        .toolbar-group input[type="number"],
        .toolbar-group input[type="text"],
        .toolbar-group select {
            width: 60px;
            padding: 4px;
            font-size: 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .toolbar-group input[type="text"] { width: 100px; }
        .toolbar-group input[type="color"] {
            width: 30px;
            height: 30px;
            padding: 0;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .toolbar-group button {
            min-width: 30px;
            height: 30px;
            padding: 5px;
            font-size: 14px;
            font-weight: bold;
            line-height: 1;
            background-color: #f0f0f0;
            color: #333;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .toolbar-group button:hover { background-color: #e0e0e0; }
        .toolbar-group button:disabled { background-color: #f9f9f9; color: #aaa; }
        #toolbarDeleteBtn { background-color: #fce8e6; color: #c82333; }
        #toolbarDeleteBtn:hover { background-color: #f8d7da; }
        #toolbarUpdateBtn { background-color: #e6f7ec; color: #218838; }
        #toolbarUpdateBtn:hover { background-color: #d4edda; }
        #toolbarLockBtn.locked { background-color: #fff0c7; }
        .toolbar-group input:disabled,
        .toolbar-group select:disabled {
            background-color: #f0f0f0;
            color: #888;
        }

        /* æ‰‹æ©Ÿç‰ˆéŸ¿æ‡‰å¼æ¨£å¼ (ç„¡è®Šæ›´) */
        @media (max-width: 768px) {
            body { flex-direction: column; height: 100vh; }
            .controls { width: 100%; height: 40vh; flex-shrink: 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1); transform: translateY(0); }
            .controls.collapsed { height: 0; padding-top: 0; padding-bottom: 0; transform: translateY(-40vh); box-shadow: none; }
            #canvas-wrapper { height: 100vh; }
            #toggleControlsBtn { top: auto; bottom: 10px; left: 10px; writing-mode: horizontal-tb; line-height: 38px; }
            #toggleControlsBtn.collapsed { transform: none; }
        }

    </style>
</head>
<body>

    <button id="toggleControlsBtn" title="åˆ‡æ›æ§åˆ¶é¢æ¿">&laquo;</button>

    <div class="controls">
        <h3>è¦–åœ– & è¨­å®š</h3>
        <div class="control-group control-row">
            <button id="zoomInBtn">+</button>
            <button id="zoomOutBtn">-</button>
            <button id="zoomResetBtn">100%</button>
        </div>
        <div class="control-group control-row">
            <button id="undoBtn" class="secondary" disabled>ä¸Šä¸€æ­¥</button>
            <button id="redoBtn" class="secondary" disabled>ä¸‹ä¸€æ­¥</button>
        </div>
        <div class="control-group control-row">
            <button id="panModeBtn" class="secondary">å¹³ç§»æ¨¡å¼ (ğŸ–ï¸)</button>
            <button id="multiSelectModeBtn" class="secondary">å¤šé¸æ¨¡å¼ ( M )</button>
        </div>
        <div class="control-group">
            <button id="zoomFitBtn" class="info">è‡ªå‹•ç¸®æ”¾ (ğŸ‘ï¸)</button>
        </div>
        <div class="control-group checkbox-group">
            <input type="checkbox" id="preventOverlap">
            <label for="preventOverlap">ç¦æ­¢å®¶å…·é‡ç–Š (é™0/90åº¦)</label>
        </div>
        <div class="control-group checkbox-group">
            <input type="checkbox" id="enableSnapping" checked>
            <label for="enableSnapping">å•Ÿç”¨é‚Šç·£å¸é™„ (é™0/90åº¦)</label>
        </div>


        <h3>å°ˆæ¡ˆ (åˆ†äº«/åŒ¯å…¥)</h3>
        <div class="control-group">
            <label for="importExportArea">ä½ˆå±€ä»£ç¢¼ (æ©Ÿå™¨ç¢¼)</label>
            <textarea id="importExportArea" rows="4" placeholder="è²¼ä¸Šä»£ç¢¼, æˆ–é»æ“Šä¸‹æ–¹åŒ¯å‡º..."></textarea>
            <button id="importTextBtn" class="secondary" style="margin-top:10px;">å¾ä»£ç¢¼åŒ¯å…¥</button>
            <button id="exportTextBtn">åŒ¯å‡ºç‚ºä»£ç¢¼</button>
        </div>
        <div class="control-group">
             <button id="exportTelegramBtn" class="secondary">å‚³é€åˆ° Telegram (è£åˆ‡åœ–ç‰‡)</button>
            <button id="clearBtn" class="danger">æ¸…ç©ºæ‰€æœ‰</button>
        </div>

        <h3>ç‰©ä»¶åº«</h3>
        <div class="control-group">
            <button id="saveToLibraryBtn" class="info" disabled>å„²å­˜é¸ä¸­è‡³åº«</button>
            <div id="libraryItems">
                </div>
        </div>


        <h3>æ–°å¢é …ç›®</h3>
        
        <h4 class="collapsible" data-target="addRoomSection">
            æ–°å¢æˆ¿é–“
            <button class="toggle-section-btn" title="æ”¶åˆ/å±•é–‹">-</button>
        </h4>
        <div id="addRoomSection" class="controls-section">
            <div class="control-group">
                <label for="roomWidth">å¯¬åº¦ (cm)</label>
                <input type="number" id="roomWidth" value="500">
            </div>
            <div class="control-group">
                <label for="roomHeight">é•·åº¦ (cm)</label>
                <input type="number" id="roomHeight" value="400">
            </div>
            <div class="control-group">
                <label for="roomLabel">å‚™è¨»</label>
                <input type="text" id="roomLabel" value="å®¢å»³">
            </div>
            <div class="control-group">
                <label for="roomRotation">æ—‹è½‰è§’åº¦ (deg)</label>
                <input type="number" id="roomRotation" value="0" step="1">
            </div>
            <button id="addRoomBtn">æ–°å¢æˆ¿é–“</button>
        </div>

        <h4 class="collapsible" data-target="addFurnitureSection" style="margin-top: 15px;">
            æ–°å¢å®¶å…·
            <button class="toggle-section-btn" title="æ”¶åˆ/å±•é–‹">-</button>
        </h4>
        <div id="addFurnitureSection" class="controls-section">
            <div class="control-group">
                <label for="furnWidth">å¯¬åº¦ (cm)</label>
                <input type="number" id="furnWidth" value="180">
            </div>
            <div class="control-group">
                <label for="furnHeight">é•·åº¦ (cm)</label>
                <input type="number" id="furnHeight" value="90">
            </div>
            <div class="control-group">
                <label for="furnShape">å½¢ç‹€</label>
                <select id="furnShape">
                    <option value="rectangle">å››æ–¹å½¢</option>
                    <option value="circle">åœ“å½¢/æ©¢åœ“</option>
                    <option value="triangle-up">ä¸‰è§’å½¢</option>
                    <option value="trapezoid-up">æ¢¯å½¢</option>
                </select>
            </div>
            <div class="control-group">
                <label for="furnColor">é¡è‰²</label>
                <input type="color" id="furnColor" value="#a3b18a">
            </div>
            <div class="control-group">
                <label for="furnOpacity">é€æ˜åº¦ (<span id="opacityValue">100</span>%)</label>
                <input type="range" id="furnOpacity" min="10" max="100" value="100">
            </div>
            <div class="control-group">
                <label for="furnLabel">å‚™è¨»</label>
                <input type="text" id="furnLabel" value="æ²™ç™¼">
            </div>
            <div class="control-group">
                <label for="furnRotation">æ—‹è½‰è§’åº¦ (deg)</label>
                <input type="number" id="furnRotation" value="0" step="1">
            </div>
            <button id="addFurnitureBtn">æ–°å¢å®¶å…·</button>
        </div>

        <h4 class="collapsible" data-target="addTextSection" style="margin-top: 15px;">
            æ–°å¢æ–‡å­—
            <button class="toggle-section-btn" title="æ”¶åˆ/å±•é–‹">-</button>
        </h4>
        <div id="addTextSection" class="controls-section">
            <div class="control-group">
                <label for="textLabel">æ–‡å­—å…§å®¹</label>
                <input type="text" id="textLabel" value="èªªæ˜æ–‡å­—">
            </div>
            <div class="control-group">
                <label for="textWidth">å¯¬åº¦ (cm)</label>
                <input type="number" id="textWidth" value="150">
            </div>
            <div class="control-group">
                <label for="textHeight">é•·åº¦ (cm)</label>
                <input type="number" id="textHeight" value="50">
            </div>
            <div class="control-group">
                <label for="textColor">é¡è‰²</label>
                <input type="color" id="textColor" value="#333333">
            </div>
            <div class="control-group">
                <label for="textRotation">æ—‹è½‰è§’åº¦ (deg)</label>
                <input type="number" id="textRotation" value="0" step="1">
            </div>
            <button id="addTextBtn">æ–°å¢æ–‡å­—</button>
        </div>

    </div>

    <div id="canvas-wrapper">
        <div id="canvas">
             <div id="floating-toolbar">
                <div class="toolbar-group">
                    <label>å¯¬:</label><input type="number" id="toolbarWidth" step="10">
                    <label>é•·:</label><input type="number" id="toolbarHeight" step="10">
                </div>
                <div class="toolbar-group">
                    <label>å‚™è¨»:</label><input type="text" id="toolbarLabel">
                </div>
                <div class="toolbar-group">
                    <label>æ—‹è½‰:</label><input type="number" id="toolbarRotation" step="5">
                    <label>é¡è‰²:</label><input type="color" id="toolbarColor">
                </div>
                <div class="toolbar-group">
                     <label>å½¢ç‹€:</label>
                     <select id="toolbarShape">
                        <option value="rectangle">æ–¹å½¢</option>
                        <option value="circle">åœ“å½¢</option>
                        <option value="triangle-up">ä¸‰è§’</option>
                        <option value="trapezoid-up">æ¢¯å½¢</option>
                    </select>
                    <button id="toolbarUpdateBtn" title="æ›´æ–°">âœ”ï¸</button>
                </div>
                 <div class="toolbar-group">
                    <button id="toolbarBringForwardBtn" title="ä¸Šç§»ä¸€å±¤">ğŸ”¼</button>
                    <button id="toolbarSendBackwardBtn" title="ä¸‹ç§»ä¸€å±¤">ğŸ”½</button>
                    <button id="toolbarBringToFrontBtn" title="ç½®æ–¼é ‚å±¤">â«</button>
                    <button id="toolbarSendToBackBtn" title="ç½®æ–¼åº•å±¤">â¬</button>
                </div>
                <div class="toolbar-group">
                    <button id="toolbarGroupBtn" title="è¨­ç‚ºç¾¤çµ„">G+</button>
                    <button id="toolbarUngroupBtn" title="å–æ¶ˆç¾¤çµ„">G-</button>
                    <button id="toolbarLockBtn" title="é–å®š/è§£é–">ğŸ”’</button>
                    <button id="toolbarDeleteBtn" title="åˆªé™¤">ğŸ—‘ï¸</button>
                </div>
            </div>
        </div>
        <div id="selectionBox"></div>
    </div>

    <script>
        // (*** v14.0 ***)

        // --- æ¯”ä¾‹å°º & å¸¸æ•¸ ---
        const SCALE = 1.5;
        const SNAP_DISTANCE = 10;
        const Z_INDEX_ROOM_BASE = 50;   
        const Z_INDEX_FURN_BASE = 100;  
        const Z_INDEX_STEP = 1;         
        const CURRENT_LAYOUT_VERSION = "14.0"; // (*** v14.0 å‡ç´šç‰ˆæœ¬è™Ÿ ***)

        // Telegram Bot è¨­å®š (ç„¡è®Šæ›´)
        const TELEGRAM_BOT_TOKEN = "7659930552:AAF_jF1rAXFnjFO176-9X5fKfBwbrko8BNc";
        const TELEGRAM_CHAT_ID = "-1002658082392";

        // ç²å–å…ƒç´ 
        const controlsPanel = document.querySelector('.controls'); 
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const canvas = document.getElementById('canvas');
        const addRoomBtn = document.getElementById('addRoomBtn');
        const addFurnitureBtn = document.getElementById('addFurnitureBtn');
        const addTextBtn = document.getElementById('addTextBtn');
        const opacitySlider = document.getElementById('furnOpacity');
        const opacityValue = document.getElementById('opacityValue');
        const selectionBox = document.getElementById('selectionBox'); 
        const toggleControlsBtn = document.getElementById('toggleControlsBtn');

        // æµ®å‹•å·¥å…·æ¬„å…ƒç´  (ç„¡è®Šæ›´)
        const floatingToolbar = document.getElementById('floating-toolbar');
        const toolbarWidth = document.getElementById('toolbarWidth');
        const toolbarHeight = document.getElementById('toolbarHeight');
        const toolbarLabel = document.getElementById('toolbarLabel');
        const toolbarRotation = document.getElementById('toolbarRotation');
        const toolbarColor = document.getElementById('toolbarColor');
        const toolbarShape = document.getElementById('toolbarShape');
        const toolbarUpdateBtn = document.getElementById('toolbarUpdateBtn');
        const toolbarDeleteBtn = document.getElementById('toolbarDeleteBtn');
        const toolbarGroupBtn = document.getElementById('toolbarGroupBtn');
        const toolbarUngroupBtn = document.getElementById('toolbarUngroupBtn');
        const toolbarLockBtn = document.getElementById('toolbarLockBtn');
        const toolbarBringForwardBtn = document.getElementById('toolbarBringForwardBtn');
        const toolbarSendBackwardBtn = document.getElementById('toolbarSendBackwardBtn');
        const toolbarBringToFrontBtn = document.getElementById('toolbarBringToFrontBtn');
        const toolbarSendToBackBtn = document.getElementById('toolbarSendToBackBtn');
        const saveToLibraryBtn = document.getElementById('saveToLibraryBtn');


        // å…¨å±€è®Šæ•¸ (ç„¡è®Šæ›´)
        let selectedItems = []; 
        let zoomLevel = 1.0;
        let isPanMode = false; 
        let isMultiSelectMode = false;
        let panStartX = 0, panStartY = 0, scrollStartX = 0, scrollStartY = 0; 
        let isSelectingBox = false; 
        let selectionStartX = 0, selectionStartY = 0; 

        // æ­·å²ç´€éŒ„åŠŸèƒ½è®Šæ•¸ (ç„¡è®Šæ›´)
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        let historyStack = [];
        let redoStack = [];
        let stateBeforeDrag = null;
        let dragOffsetX = 0, dragOffsetY = 0;

        // è¼”åŠ©å‡½å¼ (ç„¡è®Šæ›´)
        function getEventCoords(e) {
            if (e.touches && e.touches.length) { return { x: e.touches[0].clientX, y: e.touches[0].clientY }; }
            if (e.changedTouches && e.changedTouches.length) { return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY }; }
            return { x: e.clientX, y: e.clientY };
        }
        function hexToRgb(hex) {
            let r = 0, g = 0, b = 0;
            if (!hex) return {r:0,g:0,b:0}; 
            if (hex.length == 4) { r = parseInt(hex[1] + hex[1], 16); g = parseInt(hex[2] + hex[2], 16); b = parseInt(hex[3] + hex[3], 16); }
            else if (hex.length == 7) { r = parseInt(hex.substring(1, 3), 16); g = parseInt(hex.substring(3, 5), 16); b = parseInt(hex.substring(5, 7), 16); }
            return { r, g, b };
        }
        opacitySlider.oninput = function() { opacityValue.innerText = this.value; }

        // --- åŠŸèƒ½ A-0: å´é‚Šæ¬„å€å¡Šæ”¶åˆ (ç„¡è®Šæ›´) ---
        document.querySelectorAll('.collapsible').forEach(header => {
            header.onclick = function() {
                const targetId = this.dataset.target;
                const targetElement = document.getElementById(targetId);
                const button = this.querySelector('.toggle-section-btn');
                if (targetElement) {
                    targetElement.classList.toggle('collapsed');
                    if (targetElement.classList.contains('collapsed')) {
                        button.textContent = '+';
                    } else {
                        button.textContent = '-';
                    }
                }
            };
        });


        // --- åŠŸèƒ½ A-1: å´é‚Šæ¬„æ§åˆ¶ (ç„¡è®Šæ›´) ---
        function toggleControls(show) {
            const isCollapsed = controlsPanel.classList.contains('collapsed');
            const isMobile = window.innerWidth <= 768;
            let shouldShow = show;
            if (show === undefined) { shouldShow = isCollapsed; }
            if (shouldShow) {
                controlsPanel.classList.remove('collapsed');
                toggleControlsBtn.classList.remove('collapsed');
                toggleControlsBtn.innerHTML = isMobile ? 'â–½' : '&laquo;';
                toggleControlsBtn.title = 'éš±è—æ§åˆ¶é¢æ¿';
            } else {
                controlsPanel.classList.add('collapsed');
                toggleControlsBtn.classList.add('collapsed');
                toggleControlsBtn.innerHTML = isMobile ? 'â–³' : '&raquo;';
                toggleControlsBtn.title = 'é¡¯ç¤ºæ§åˆ¶é¢æ¿';
            }
        }
        toggleControlsBtn.onclick = () => toggleControls();
        if (window.innerWidth <= 768) { toggleControlsBtn.innerHTML = 'â–½'; }


        // --- åŠŸèƒ½ A-2: è¦–åœ–ç¸®æ”¾ (ç„¡è®Šæ›´) ---
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomResetBtn = document.getElementById('zoomResetBtn');
        const zoomFitBtn = document.getElementById('zoomFitBtn'); 
        function applyZoom(newZoomLevel, centerX, centerY) {
            const currentZoom = zoomLevel;
            newZoomLevel = Math.max(0.2, Math.min(newZoomLevel, 3.0)); 
            if (newZoomLevel === currentZoom) return;
            const scrollX = canvasWrapper.scrollLeft, scrollY = canvasWrapper.scrollTop;
            const canvasRect = canvas.getBoundingClientRect();
            const relativeX = centerX - canvasRect.left, relativeY = centerY - canvasRect.top;
            const dx = (relativeX / currentZoom) * (newZoomLevel - currentZoom);
            const dy = (relativeY / currentZoom) * (newZoomLevel - currentZoom);
            zoomLevel = newZoomLevel;
            canvas.style.transform = `scale(${zoomLevel})`;
            canvasWrapper.scrollLeft = scrollX + dx;
            canvasWrapper.scrollTop = scrollY + dy;
        }
        zoomInBtn.onclick = () => { const rect = canvasWrapper.getBoundingClientRect(); applyZoom(zoomLevel + 0.1, rect.left + rect.width / 2, rect.top + rect.height / 2); };
        zoomOutBtn.onclick = () => { const rect = canvasWrapper.getBoundingClientRect(); applyZoom(zoomLevel - 0.1, rect.left + rect.width / 2, rect.top + rect.height / 2); };
        zoomResetBtn.onclick = () => { const rect = canvasWrapper.getBoundingClientRect(); applyZoom(1.0, rect.left + rect.width / 2, rect.top + rect.height / 2); };
        canvasWrapper.addEventListener('wheel', (e) => {
            if (isPanMode) return; 
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            applyZoom(zoomLevel + delta, e.clientX, e.clientY);
        }, { passive: false }); 

        // --- åŠŸèƒ½ A-3: è‡ªå‹•ç¸®æ”¾ (Fit to View) (ç„¡è®Šæ›´) ---
        zoomFitBtn.onclick = function() {
            const items = canvas.querySelectorAll('.room, .furniture');
            if (items.length === 0) { zoomResetBtn.onclick(); return; }
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            items.forEach(item => {
                const rect = item.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                const left = (rect.left - canvasRect.left) / zoomLevel;
                const top = (rect.top - canvasRect.top) / zoomLevel;
                const right = (rect.right - canvasRect.left) / zoomLevel;
                const bottom = (rect.bottom - canvasRect.top) / zoomLevel;
                if (left < minX) minX = left;
                if (top < minY) minY = top;
                if (right > maxX) maxX = right;
                if (bottom > maxY) maxY = bottom;
            });
            if (minX === Infinity) return;
            const padding = 50; 
            const boundsWidth = (maxX - minX) + padding * 2;
            const boundsHeight = (maxY - minY) + padding * 2;
            const boundsCenterX = minX + (boundsWidth - padding * 2) / 2;
            const boundsCenterY = minY + (boundsHeight - padding * 2) / 2;
            const wrapperRect = canvasWrapper.getBoundingClientRect();
            const wrapperWidth = wrapperRect.width, wrapperHeight = wrapperRect.height;
            const zoomX = wrapperWidth / boundsWidth, zoomY = wrapperHeight / boundsHeight;
            const newZoom = Math.min(zoomX, zoomY, 2.0);
            toggleControls(false);
            zoomLevel = newZoom;
            canvas.style.transform = `scale(${zoomLevel})`;
            const newScrollLeft = (boundsCenterX * newZoom) - (wrapperWidth / 2);
            const newScrollTop = (boundsCenterY * newZoom) - (wrapperHeight / 2);
            canvasWrapper.scrollLeft = newScrollLeft;
            canvasWrapper.scrollTop = newScrollTop;
        }


        // --- åŠŸèƒ½ B: æ­·å²ç´€éŒ„ (Undo/Redo) ---
        
        // (*** v14.0 ä¿®æ”¹ ***) B-1: å–å¾—ç•¶å‰ç‹€æ…‹ (ç§»é™¤ fontSize, å› ç‚ºå…¨è‡ªå‹•äº†)
        function getCurrentState() {
            const layoutData = { rooms: [], furniture: [], textObjects: [] };
            
            canvas.querySelectorAll('.room, .furniture, .text-object').forEach(item => {
                let itemData = {
                    id: item.dataset.id, 
                    left: item.style.left, top: item.style.top,
                    width: item.style.width, height: item.style.height,
                    cmWidth: item.dataset.cmWidth, cmHeight: item.dataset.cmHeight,
                    label: item.dataset.label, 
                    // fontSize: item.dataset.fontSize, // (*** v14.0 ***) ç§»é™¤
                    rotation: item.dataset.rotation, zIndex: item.style.zIndex,
                    isLocked: item.dataset.isLocked === 'true',
                    itemType: item.dataset.itemType || 'unknown'
                };

                if (itemData.itemType === 'room') {
                    layoutData.rooms.push(itemData);
                } else if (itemData.itemType === 'text') {
                    itemData.color = item.dataset.colorHex;
                    layoutData.textObjects.push(itemData);
                } else if (itemData.itemType === 'furniture') {
                    itemData.groupId = item.dataset.groupId || null; 
                    itemData.color = item.dataset.colorHex; 
                    itemData.opacity = item.dataset.opacity;
                    itemData.shape = item.dataset.shape || 'rectangle';
                    layoutData.furniture.push(itemData);
                }
            });

            return {
                version: CURRENT_LAYOUT_VERSION,
                layout: layoutData
            };
        }

        // (*** v14.0 ä¿®æ”¹ ***) B-2: è¼‰å…¥ç‹€æ…‹ (ç§»é™¤ fontSize)
        function loadLayout(layoutData) {
            clearSelection(); 
            clearCanvas(false);
            if (!layoutData) { console.error("Invalid layout data to load."); return; }

            (layoutData.rooms || []).forEach((roomData) => {
                const room = createRoomElement(
                    roomData.cmWidth || 500, roomData.cmHeight || 400, 
                    roomData.label || 'Room', // roomData.fontSize (ç§»é™¤)
                    roomData.rotation || 0, roomData.id
                );
                room.style.left = roomData.left; room.style.top = roomData.top;
                room.style.zIndex = roomData.zIndex || Z_INDEX_ROOM_BASE; 
                canvas.appendChild(room);
                updateAndScaleLabel(room); 
                if (roomData.isLocked) {
                    room.dataset.isLocked = 'true';
                    room.classList.add('locked');
                }
                makeDraggable(room); 
                addSelectionListeners(room);
            });

            (layoutData.furniture || []).forEach(furnData => {
                const furniture = createFurnitureElement(
                    furnData.cmWidth || 100, furnData.cmHeight || 50,
                    furnData.shape || 'rectangle', furnData.color || '#cccccc',
                    furnData.label || 'Furniture', furnData.opacity || 1,
                    // furnData.fontSize (ç§»é™¤)
                    furnData.rotation || 0, furnData.id
                );
                furniture.style.left = furnData.left; furniture.style.top = furnData.top;
                furniture.style.zIndex = furnData.zIndex || Z_INDEX_FURN_BASE; 
                if (furnData.groupId) furniture.dataset.groupId = furnData.groupId; 
                canvas.appendChild(furniture);
                updateAndScaleLabel(furniture); 
                if (furnData.isLocked) {
                    furniture.dataset.isLocked = 'true';
                    furniture.classList.add('locked');
                }
                makeDraggable(furniture); 
                addSelectionListeners(furniture);
            });

            (layoutData.textObjects || []).forEach(textData => {
                const textObj = createTextElement(
                    textData.label || 'Text', // textData.fontSize (ç§»é™¤)
                    textData.color || '#333333', textData.rotation || 0,
                    textData.cmWidth || 150, textData.cmHeight || 50,
                    textData.id
                );
                textObj.style.left = textData.left; textObj.style.top = textData.top;
                textObj.style.zIndex = textData.zIndex || Z_INDEX_FURN_BASE; 
                canvas.appendChild(textObj);
                updateAndScaleLabel(textObj); 
                if (textData.isLocked) {
                    textObj.dataset.isLocked = 'true';
                    textObj.classList.add('locked');
                }
                makeDraggable(textObj); 
                addSelectionListeners(textObj);
            });
        }
        
        // B-2.1: çµ±ä¸€çš„é»æ“Š/è§¸æ§äº‹ä»¶ç¶å®š (ç„¡è®Šæ›´)
        function addSelectionListeners(element) {
            element.addEventListener('click', (e) => { 
                e.stopPropagation(); 
                toggleSelection(element, e.shiftKey); 
            });
            element.addEventListener('touchstart', (e) => { 
                e.stopPropagation(); 
                handleItemTouch(e, element);
            }, { passive: false });
        }
        
        // B-2.2: è™•ç†æ‰‹æ©Ÿè§¸æ§ (ç„¡è®Šæ›´)
        function handleItemTouch(e, item) {
            if (isMultiSelectMode) {
                e.preventDefault(); 
                toggleSelection(item, true); 
            } else {
                toggleSelection(item, false);
            }
        }

        // (*** v14.0 ä¿®æ”¹ ***) B-2.5: ä½ˆå±€ç‰ˆæœ¬é·ç§»
        function migrateLayout(data, fromVersion) {
            if (fromVersion === CURRENT_LAYOUT_VERSION) return data; 
            let migratedData = JSON.parse(JSON.stringify(data)); 
            console.log(`æ­£åœ¨å¾ ${fromVersion} é·ç§»åˆ° ${CURRENT_LAYOUT_VERSION}...`);

            if (fromVersion === "pre-10.0" || fromVersion === "10.0") {
                 fromVersion = "11.0";
            }
            if (fromVersion === "11.0") {
                (migratedData.rooms || []).forEach(item => {
                    item.isLocked = false;
                    item.itemType = 'room';
                });
                (migratedData.furniture || []).forEach(item => {
                    item.isLocked = false;
                    item.itemType = 'furniture';
                    item.shape = item.shape || (item.style?.borderRadius === '50%' ? 'circle' : 'rectangle');
                });
                migratedData.textObjects = [];
                console.log("... '11.0' -> '12.0' é·ç§»ã€‚");
                fromVersion = "12.0";
            }
            if (fromVersion === "12.0" || fromVersion === "13.0") {
                 // v13.0 é·ç§»åˆ° v14.0
                 // (ç§»é™¤ fontSize å±¬æ€§)
                 (migratedData.rooms || []).forEach(item => delete item.fontSize);
                 (migratedData.furniture || []).forEach(item => delete item.fontSize);
                 (migratedData.textObjects || []).forEach(item => delete item.fontSize);
                 console.log(`... '${fromVersion}' -> '14.0' é·ç§» (ç§»é™¤ fontSize)ã€‚`);
                 fromVersion = "14.0";
            }
            
            console.log("é·ç§»å®Œæˆã€‚");
            return migratedData;
        }

        // B-3 ~ B-6 (æ­·å²ç´€éŒ„æ ¸å¿ƒåŠŸèƒ½ç„¡è®Šæ›´)
        function updateUndoRedoButtons() {
            undoBtn.disabled = historyStack.length === 0;
            redoBtn.disabled = redoStack.length === 0;
        }
        function saveStateForUndo(actionDescription = "") { 
            redoStack = [];
            historyStack.push(getCurrentState()); 
            if (historyStack.length > 50) historyStack.shift();
            updateUndoRedoButtons();
        }
        undoBtn.onclick = function() {
            if (historyStack.length === 0) return;
            redoStack.push(getCurrentState());
            const stateToLoad = historyStack.pop(); 
            loadLayout(stateToLoad.layout); 
            updateUndoRedoButtons();
        };
        redoBtn.onclick = function() {
            if (redoStack.length === 0) return;
            historyStack.push(getCurrentState());
            const stateToLoad = redoStack.pop(); 
            loadLayout(stateToLoad.layout); 
            updateUndoRedoButtons();
        };

        // --- åŠŸèƒ½ C: å°ˆæ¡ˆ (ä»£ç¢¼åŒ¯å…¥ / åŒ¯å‡º / Telegram) ---
        
        // C-1: åŒ¯å‡ºç‚ºä»£ç¢¼ (ç„¡è®Šæ›´)
        const importTextBtn = document.getElementById('importTextBtn');
        const exportTextBtn = document.getElementById('exportTextBtn');
        const exportTelegramBtn = document.getElementById('exportTelegramBtn');
        const clearBtn = document.getElementById('clearBtn');
        const importExportArea = document.getElementById('importExportArea');
        exportTextBtn.onclick = function() {
            importExportArea.value = JSON.stringify(getCurrentState(), null, 2);
            alert('ä»£ç¢¼å·²åŒ¯å‡ºåˆ°ä¸Šæ–¹çš„æ–‡å­—æ¡†ï¼');
        };

        // (*** v14.0 ä¿®æ”¹ ***) C-2: å¾ä»£ç¢¼åŒ¯å…¥
        importTextBtn.onclick = function() {
            const dataString = importExportArea.value;
            if (!dataString) { alert('è«‹å…ˆåœ¨æ–‡å­—æ¡†ä¸­è²¼ä¸Šä½ˆå±€ä»£ç¢¼ã€‚'); return; }
            let parsedData;
            try { parsedData = JSON.parse(dataString); }
            catch (e) { alert('ä»£ç¢¼æ ¼å¼éŒ¯èª¤ï¼Œç„¡æ³•è§£æã€‚\n' + e.message); return; }

            let dataToLoad;
            let sourceVersion = "pre-10.0"; 

            if (parsedData.version && parsedData.layout) {
                 sourceVersion = parsedData.version;
                 dataToLoad = migrateLayout(parsedData.layout, sourceVersion);
            } else if (Array.isArray(parsedData.rooms) || Array.isArray(parsedData.furniture)) {
                 dataToLoad = migrateLayout(parsedData, sourceVersion);
            } else {
                 alert('ç„¡æ³•è­˜åˆ¥çš„ä»£ç¢¼æ ¼å¼ã€‚');
                 return;
            }

            historyStack = [];
            redoStack = [];
            loadLayout(dataToLoad); 
            historyStack.push(getCurrentState()); 
            updateUndoRedoButtons();

            alert('ä½ˆå±€å·²å¾ä»£ç¢¼è¼‰å…¥ï¼');
        };

        // C-3: å‚³é€åˆ° Telegram (è‡ªå‹•è£åˆ‡) (ç„¡è®Šæ›´)
        exportTelegramBtn.onclick = async function() {
            alert('æ­£åœ¨æº–å‚™å‚³é€ (è‡ªå‹•è£åˆ‡)... è«‹ç¨å€™ã€‚');
            clearSelection();
            
            const items = canvas.querySelectorAll('.room, .furniture, .text-object');
            if (items.length === 0) {
                alert('ç•«å¸ƒä¸Šæ²’æœ‰å…§å®¹å¯ä»¥å‚³é€ã€‚');
                return;
            }

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            items.forEach(item => {
                const rect = item.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                const left = (rect.left - canvasRect.left) / zoomLevel;
                const top = (rect.top - canvasRect.top) / zoomLevel;
                const right = (rect.right - canvasRect.left) / zoomLevel;
                const bottom = (rect.bottom - canvasRect.top) / zoomLevel;
                if (left < minX) minX = left;
                if (top < minY) minY = top;
                if (right > maxX) maxX = right;
                if (bottom > maxY) maxY = bottom;
            });
            if (minX === Infinity) { alert('ç„¡æ³•è¨ˆç®—é‚Šç•Œã€‚'); return; }
            
            const padding = 20; 
            const cropX = minX - padding;
            const cropY = minY - padding;
            const cropWidth = (maxX - minX) + padding * 2;
            const cropHeight = (maxY - minY) + padding * 2;

            let canvasImageBlob, layoutDataString;

            try {
                const canvasImageElement = await html2canvas(canvas, { 
                    useCORS: true, 
                    backgroundColor: '#e9ebee',
                    x: cropX,
                    y: cropY,
                    width: cropWidth,
                    height: cropHeight,
                    scale: 2
                });
                canvasImageBlob = await new Promise(resolve => canvasImageElement.toBlob(resolve, 'image/png'));
                layoutDataString = JSON.stringify(getCurrentState(), null, 2);
            } catch (err) {
                alert('ç”¢ç”Ÿè³‡æ–™å¤±æ•—: ' + err.message);
                return;
            }

            // å‚³é€åœ–ç‰‡
            try {
                const formData = new FormData();
                formData.append('chat_id', TELEGRAM_CHAT_ID);
                formData.append('photo', canvasImageBlob, 'layout.png');
                formData.append('caption', 'ä½ˆå±€é è¦½åœ– (Layout Preview)');
                const photoRes = await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendPhoto`, { method: 'POST', body: formData });
                const photoJson = await photoRes.json();
                if (!photoJson.ok) throw new Error('åœ–ç‰‡å‚³é€å¤±æ•—: ' + (photoJson.description || 'Unknown error'));
            } catch (err) {
                alert('å‚³é€åœ–ç‰‡å¤±æ•—: ' + err.message);
                return;
            }

            // å‚³é€ä½ˆå±€ä»£ç¢¼
            try {
                const MAX_MSG_LENGTH = 4096;
                const messageText = 'ä½ˆå±€æ©Ÿå™¨ç¢¼ (Layout Code):\n```json\n' + layoutDataString + '\n```';
                if (messageText.length <= MAX_MSG_LENGTH) {
                    const msgRes = await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ chat_id: TELEGRAM_CHAT_ID, text: messageText, parse_mode: 'Markdown' })
                    });
                    const msgJson = await msgRes.json();
                    if (!msgJson.ok) throw new Error(msgJson.description);
                } else {
                    throw new Error("Message too long, sending as file.");
                }
                alert('æˆåŠŸå‚³é€åˆ° Telegram (è£åˆ‡åœ–ç‰‡ + æ©Ÿå™¨ç¢¼)ï¼');
            } catch (err) {
                console.warn("Text message failed, attempting to send as file:", err.message);
                try {
                    const jsonBlob = new Blob([layoutDataString], { type: 'application/json' });
                    const docFormData = new FormData();
                    docFormData.append('chat_id', TELEGRAM_CHAT_ID);
                    docFormData.append('document', jsonBlob, 'layout.json');
                    docFormData.append('caption', 'ä½ˆå±€æ©Ÿå™¨ç¢¼ (Layout Code)');
                    const docRes = await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendDocument`, { method: 'POST', body: docFormData });
                    const docJson = await docRes.json();
                    if (!docJson.ok) throw new Error('JSONæª”æ¡ˆå‚³é€å¤±æ•—: ' + (docJson.description || 'Unknown error'));
                    alert('æˆåŠŸå‚³é€åˆ° Telegram (è£åˆ‡åœ–ç‰‡ + JSON æª”æ¡ˆ)ï¼');
                } catch (fileErr) {
                    alert('å‚³é€æ©Ÿå™¨ç¢¼å¤±æ•—: ' + fileErr.message);
                }
            }
        };


        // C-4: æ¸…ç©ºç•«å¸ƒ (ç„¡è®Šæ›´)
        clearBtn.onclick = function() {
            if (confirm('ç¢ºå®šè¦æ¸…ç©ºæ‰€æœ‰æˆ¿é–“å’Œå®¶å…·å—ï¼Ÿ')) {
                saveStateForUndo("Clear Canvas");
                clearCanvas(false);
                updateUndoRedoButtons();
            }
        };
        function clearCanvas(saveHistory = true) {
            if (saveHistory) saveStateForUndo("Clear Canvas Internal");
            canvas.innerHTML = ''; 
            canvas.appendChild(floatingToolbar); 
            clearSelection();
            if (saveHistory) updateUndoRedoButtons();
        }

        // --- åŠŸèƒ½ D: é¸å–ç®¡ç† (v12.0) (ç„¡è®Šæ›´) ---

        // D-1: æ¸…é™¤æ‰€æœ‰é¸å–
        function clearSelection() {
            selectedItems.forEach(item => item.classList.remove('selected'));
            selectedItems = [];
            updateSelectionUI();
        }

        // D-2: è¨­å®šé¸å–
        function setSelection(items) {
            clearSelection(); 
            selectedItems = Array.isArray(items) ? items : [items]; 
            selectedItems.forEach(item => item.classList.add('selected'));
            updateSelectionUI();
        }

        // D-3: åˆ‡æ›é¸å–
        function toggleSelection(item, forceMultiSelect) {
            const groupId = item.dataset.groupId;
            let itemsToToggle = [item];
            if (groupId) {
                itemsToToggle = Array.from(canvas.querySelectorAll(`[data-group-id="${groupId}"]`));
            }
            
            const isMulti = forceMultiSelect || isMultiSelectMode;

            if (isMulti) {
                itemsToToggle.forEach(it => {
                    const index = selectedItems.indexOf(it);
                    if (index > -1) {
                        selectedItems.splice(index, 1);
                        it.classList.remove('selected');
                    } else {
                        selectedItems.push(it);
                        it.classList.add('selected');
                    }
                });
            } else {
                const alreadySelected = itemsToToggle.every(it => selectedItems.includes(it));
                if (selectedItems.length > itemsToToggle.length || !alreadySelected) {
                    setSelection(itemsToToggle);
                }
            }
            updateSelectionUI();
        }


        // D-4: æ›´æ–° UI ç‹€æ…‹
        function updateSelectionUI() {
            const count = selectedItems.length;

            if (count === 0) {
                floatingToolbar.classList.remove('visible');
                saveToLibraryBtn.disabled = true;
                return;
            }

            saveToLibraryBtn.disabled = count !== 1;

            const isSingleSelection = count === 1;
            const item = isSingleSelection ? selectedItems[0] : null;
            const isLocked = selectedItems.some(it => it.dataset.isLocked === 'true');
            const itemType = item ? item.dataset.itemType : null;
            const isFurniture = itemType === 'furniture';
            const isText = itemType === 'text';
            const isRoom = itemType === 'room';

            toolbarDeleteBtn.disabled = isLocked;
            toolbarGroupBtn.disabled = count < 2 || isLocked;
            toolbarUngroupBtn.disabled = !selectedItems.some(item => item.dataset.groupId) || isLocked;
            toolbarLockBtn.disabled = false;
            
            toolbarUpdateBtn.disabled = !isSingleSelection || isLocked;
            toolbarBringForwardBtn.disabled = !isSingleSelection || isLocked;
            toolbarSendBackwardBtn.disabled = !isSingleSelection || isLocked;
            toolbarBringToFrontBtn.disabled = !isSingleSelection || isLocked;
            toolbarSendToBackBtn.disabled = !isSingleSelection || isLocked;

            toolbarWidth.disabled = !isSingleSelection || isLocked;
            toolbarHeight.disabled = !isSingleSelection || isLocked;
            toolbarLabel.disabled = !isSingleSelection || isLocked;
            toolbarRotation.disabled = !isSingleSelection || isLocked;
            
            toolbarColor.disabled = !isSingleSelection || isLocked || isRoom;
            toolbarShape.disabled = !isSingleSelection || isLocked || !isFurniture;

            if (isSingleSelection) {
                toolbarWidth.value = item.dataset.cmWidth;
                toolbarHeight.value = item.dataset.cmHeight;
                toolbarLabel.value = item.dataset.label;
                toolbarRotation.value = item.dataset.rotation || 0;
                
                if (isFurniture || isText) {
                    toolbarColor.value = item.dataset.colorHex;
                } else {
                    toolbarColor.value = '#000000';
                }
                
                if (isFurniture) {
                    toolbarShape.value = item.dataset.shape || 'rectangle';
                } else {
                    toolbarShape.value = 'rectangle';
                }
                
                if (item.dataset.isLocked === 'true') {
                    toolbarLockBtn.innerHTML = 'ğŸ”“';
                    toolbarLockBtn.title = 'è§£é–';
                    toolbarLockBtn.classList.add('locked');
                } else {
                    toolbarLockBtn.innerHTML = 'ğŸ”’';
                    toolbarLockBtn.title = 'é–å®š';
                    toolbarLockBtn.classList.remove('locked');
                }

            } else {
                toolbarWidth.value = '';
                toolbarHeight.value = '';
                toolbarLabel.value = '';
                toolbarRotation.value = '';
                toolbarColor.value = '#000000';
                toolbarShape.value = 'rectangle';
                
                if (isLocked) {
                    toolbarLockBtn.innerHTML = 'ğŸ”“';
                    toolbarLockBtn.title = 'è§£é–é¸å–é …ç›®';
                    toolbarLockBtn.classList.add('locked');
                } else {
                    toolbarLockBtn.innerHTML = 'ğŸ”’';
                    toolbarLockBtn.title = 'é–å®šé¸å–é …ç›®';
                    toolbarLockBtn.classList.remove('locked');
                }
            }
            
            updateFloatingToolbarPosition();
            floatingToolbar.classList.add('visible');
        }

        // D-4.5: æ›´æ–°æµ®å‹•å·¥å…·æ¬„ä½ç½®
        function updateFloatingToolbarPosition() {
            if (selectedItems.length === 0) {
                floatingToolbar.classList.remove('visible');
                return;
            }
            const item = selectedItems[0];
            const itemRect = item.getBoundingClientRect(); 
            const canvasRect = canvas.getBoundingClientRect(); 
            const vpRight = itemRect.right;
            const vpTop = itemRect.top;
            const canvasLeft = (vpRight - canvasRect.left) / zoomLevel + 10; 
            const canvasTop = (vpTop - canvasRect.top) / zoomLevel;
            floatingToolbar.style.left = canvasLeft + 'px';
            floatingToolbar.style.top = canvasTop + 'px';
        }


        // D-5: é»æ“Š/è§¸æ§ç•«å¸ƒèƒŒæ™¯
        canvasWrapper.addEventListener('mousedown', startSelectionOrPan);
        canvasWrapper.addEventListener('touchstart', startSelectionOrPan, { passive: false });
        function startSelectionOrPan(e) {
            if (e.target !== canvasWrapper && e.target !== canvas) return;
            if (e.shiftKey || isMultiSelectMode) {
                 if (e.type === 'touchstart') e.preventDefault();
                 return;
            }

            const { x, y } = getEventCoords(e);
            if (isPanMode) {
                canvasWrapper.style.cursor = 'grabbing';
                panStartX = x; panStartY = y;
                scrollStartX = canvasWrapper.scrollLeft; scrollStartY = canvasWrapper.scrollTop;
                document.addEventListener('mousemove', panCanvas);
                document.addEventListener('mouseup', endPan);
                document.addEventListener('touchmove', panCanvas, { passive: false });
                document.addEventListener('touchend', endPan);
            } else {
                isSelectingBox = true;
                const canvasRect = canvasWrapper.getBoundingClientRect(); 
                selectionStartX = x - canvasRect.left + canvasWrapper.scrollLeft;
                selectionStartY = y - canvasRect.top + canvasWrapper.scrollTop;
                selectionBox.style.left = selectionStartX + 'px';
                selectionBox.style.top = selectionStartY + 'px';
                selectionBox.style.width = '0px';
                selectionBox.style.height = '0px';
                selectionBox.style.display = 'block';
                document.addEventListener('mousemove', dragSelectionBox);
                document.addEventListener('mouseup', endSelectionBox);
                document.addEventListener('touchmove', dragSelectionBox, { passive: false });
                document.addEventListener('touchend', endSelectionBox);
                clearSelection();
            }
        }

        // D-6: æ‹–æ›³é¸æ¡†ä¸­
        function dragSelectionBox(e) {
            if (!isSelectingBox) return;
            if (e.touches && e.cancelable) e.preventDefault();
            const { x, y } = getEventCoords(e);
            const canvasRect = canvasWrapper.getBoundingClientRect();
            const currentX = x - canvasRect.left + canvasWrapper.scrollLeft;
            const currentY = y - canvasRect.top + canvasWrapper.scrollTop;
            const left = Math.min(selectionStartX, currentX);
            const top = Math.min(selectionStartY, currentY);
            const width = Math.abs(selectionStartX - currentX);
            const height = Math.abs(selectionStartY - currentY);
            selectionBox.style.left = left + 'px';
            selectionBox.style.top = top + 'px';
            selectionBox.style.width = width + 'px';
            selectionBox.style.height = height + 'px';
        }

        // D-7: æ‹–æ›³é¸æ¡†çµæŸ
        function endSelectionBox(e) {
            if (!isSelectingBox) return;
            isSelectingBox = false;
            selectionBox.style.display = 'none';
            document.removeEventListener('mousemove', dragSelectionBox);
            document.removeEventListener('mouseup', endSelectionBox);
            document.removeEventListener('touchmove', dragSelectionBox);
            document.removeEventListener('touchend', endSelectionBox);
            const boxLeft = parseFloat(selectionBox.style.left) / zoomLevel;
            const boxTop = parseFloat(selectionBox.style.top) / zoomLevel;
            const boxWidth = parseFloat(selectionBox.style.width) / zoomLevel;
            const boxHeight = parseFloat(selectionBox.style.height) / zoomLevel;
            const boxRight = boxLeft + boxWidth;
            const boxBottom = boxTop + boxHeight;
            const itemsInBox = [];
            const allItems = canvas.querySelectorAll('.room, .furniture, .text-object');
            allItems.forEach(item => {
                const itemLeft = item.offsetLeft;
                const itemTop = item.offsetTop;
                const itemCenterX = itemLeft + item.offsetWidth / 2;
                const itemCenterY = itemTop + item.offsetHeight / 2;
                if (itemCenterX >= boxLeft && itemCenterX <= boxRight &&
                    itemCenterY >= boxTop && itemCenterY <= boxBottom) {
                    itemsInBox.push(item);
                }
            });
            if (itemsInBox.length > 0) {
                setSelection(itemsInBox);
            }
        }


        // --- åŠŸèƒ½ E: ç·¨è¼¯ / åˆªé™¤ (ä¾†è‡ªæµ®å‹•å·¥å…·æ¬„) (v12.0) (ç„¡è®Šæ›´) ---

        // E-1: åˆªé™¤ (å¤šé¸)
        function deleteSelectedItems() {
            const unlockedItems = selectedItems.filter(item => item.dataset.isLocked !== 'true');
            if (unlockedItems.length === 0) {
                 alert('é¸å–çš„é …ç›®å‡å·²é–å®šï¼Œç„¡æ³•åˆªé™¤ã€‚');
                 return;
            }
            if (confirm(`ç¢ºå®šè¦åˆªé™¤ ${unlockedItems.length} å€‹æœªé–å®šçš„é …ç›®å—ï¼Ÿ`)) {
                saveStateForUndo("Delete Selected");
                unlockedItems.forEach(item => item.remove());
                clearSelection();
            }
        };
        toolbarDeleteBtn.onclick = deleteSelectedItems;

        // E-2: æ›´æ–°
        function updateSelectedItem() {
            if (selectedItems.length !== 1) {
                 alert('è«‹åªé¸å–ä¸€å€‹é …ç›®ä¾†æ›´æ–°å±¬æ€§ã€‚');
                 return;
            }
            const item = selectedItems[0];
            
            if (item.dataset.isLocked === 'true') {
                alert('é …ç›®å·²é–å®šï¼Œè«‹å…ˆè§£é–å†æ›´æ–°ã€‚');
                return;
            }

            saveStateForUndo("Update Item");

            try {
                const width = toolbarWidth.value, height = toolbarHeight.value;
                const label = toolbarLabel.value, rotation = toolbarRotation.value;
                const color = toolbarColor.value, shape = toolbarShape.value;

                item.dataset.cmWidth = width; item.dataset.cmHeight = height;
                item.dataset.label = label; item.dataset.rotation = rotation;
                item.style.width = (width * SCALE) + 'px'; item.style.height = (height * SCALE) + 'px';
                item.style.transform = 'rotate(' + rotation + 'deg)';
                
                const itemType = item.dataset.itemType;
                
                if (itemType === 'furniture') {
                    item.dataset.colorHex = color;
                    item.dataset.shape = shape;
                    const rgb = hexToRgb(color);
                    const opacity = item.dataset.opacity;
                    item.style.backgroundColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                    applyShape(item, shape);
                } else if (itemType === 'text') {
                    item.dataset.colorHex = color;
                    item.style.color = color;
                    item.style.setProperty('--text-color', color);
                }
                
                // (*** v14.0 ***) æ›´æ–°ä¸¦é‡æ–°ç¸®æ”¾æ¨™ç±¤ (åŒ…å«å°ºå¯¸)
                updateAndScaleLabel(item);
                
                updateFloatingToolbarPosition();
            } catch (e) {
                alert('æ›´æ–°å¤±æ•—: ' + e.message);
                if (historyStack.length > 0) loadLayout(historyStack.pop().layout);
                updateUndoRedoButtons();
            }
        };
        toolbarUpdateBtn.onclick = updateSelectedItem;
        
        // E-3: åˆ‡æ›é–å®š
        function toggleLockSelected() {
            if (selectedItems.length === 0) return;
            saveStateForUndo("Toggle Lock");
            
            const shouldLock = selectedItems.some(item => item.dataset.isLocked !== 'true');
            
            selectedItems.forEach(item => {
                if (shouldLock) {
                    item.dataset.isLocked = 'true';
                    item.classList.add('locked');
                } else {
                    item.dataset.isLocked = 'false';
                    item.classList.remove('locked');
                }
            });
            updateSelectionUI();
        }
        toolbarLockBtn.onclick = toggleLockSelected;


        // --- åŠŸèƒ½ F: åœ–å±¤ç®¡ç† (v12.0) (ç„¡è®Šæ›´) ---
        function changeLayer(delta) {
            if (selectedItems.length !== 1) return;
            const item = selectedItems[0];
            if (item.dataset.isLocked === 'true') return;
            
            const currentZ = parseInt(item.style.zIndex || (item.classList.contains('room') ? Z_INDEX_ROOM_BASE : Z_INDEX_FURN_BASE));
            let newZ;
            saveStateForUndo("Change Layer");

            if (delta === Infinity) {
                let maxZ = item.dataset.itemType === 'room' ? Z_INDEX_ROOM_BASE : Z_INDEX_FURN_BASE;
                canvas.querySelectorAll('.room, .furniture, .text-object').forEach(el => {
                    const z = parseInt(el.style.zIndex);
                    if (!isNaN(z) && z > maxZ) maxZ = z;
                });
                newZ = maxZ + Z_INDEX_STEP;
            } else if (delta === -Infinity) {
                newZ = item.dataset.itemType === 'room' ? Z_INDEX_ROOM_BASE : Z_INDEX_FURN_BASE;
            } else {
                newZ = currentZ + delta * Z_INDEX_STEP;
                if (item.dataset.itemType === 'room') {
                    newZ = Math.max(Z_INDEX_ROOM_BASE, newZ);
                } else {
                    newZ = Math.max(Z_INDEX_FURN_BASE, newZ);
                }
            }
            item.style.zIndex = newZ;
        }
        toolbarBringForwardBtn.onclick = () => changeLayer(1);
        toolbarSendBackwardBtn.onclick = () => changeLayer(-1);
        toolbarBringToFrontBtn.onclick = () => changeLayer(Infinity);
        toolbarSendToBackBtn.onclick = () => changeLayer(-Infinity);


        // --- åŠŸèƒ½ G: ç¾¤çµ„ (v12.0) (ç„¡è®Šæ›´) ---
        function groupSelectedItems() {
            const unlockedItems = selectedItems.filter(item => item.dataset.isLocked !== 'true');
            if (unlockedItems.length < 2) {
                alert('è«‹é¸å–è‡³å°‘ 2 å€‹æœªé–å®šçš„é …ç›®ä¾†å»ºç«‹ç¾¤çµ„ã€‚');
                return;
            }
            saveStateForUndo("Group Items");
            const groupId = `group-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;
            unlockedItems.forEach(item => {
                item.dataset.groupId = groupId;
            });
            updateSelectionUI();
            alert(`å·²å°‡ ${unlockedItems.length} å€‹é …ç›®è¨­ç‚ºç¾¤çµ„ï¼`);
        }
        toolbarGroupBtn.onclick = groupSelectedItems;

        function ungroupSelectedItems() {
            const itemsToUngroup = selectedItems.filter(item => item.dataset.groupId && item.dataset.isLocked !== 'true');
            if (itemsToUngroup.length === 0) {
                 alert('é¸å–çš„é …ç›®æ²’æœ‰å¯è§£æ•£çš„ç¾¤çµ„ (æˆ–å·²è¢«é–å®š)ã€‚');
                 return;
            }
            saveStateForUndo("Ungroup Items");
            itemsToUngroup.forEach(item => {
                delete item.dataset.groupId;
            });
            updateSelectionUI();
             alert(`å·²å°‡ ${itemsToUngroup.length} å€‹é …ç›®å–æ¶ˆç¾¤çµ„ï¼`);
        }
        toolbarUngroupBtn.onclick = ungroupSelectedItems;


        // --- åŠŸèƒ½ H: å¹³ç§» & å¤šé¸ æ¨¡å¼ (v12.0) (ç„¡è®Šæ›´) ---
        const panModeBtn = document.getElementById('panModeBtn');
        const multiSelectModeBtn = document.getElementById('multiSelectModeBtn');

        panModeBtn.onclick = function() {
            isPanMode = !isPanMode;
            if (isPanMode) {
                if (isMultiSelectMode) multiSelectModeBtn.click(); 
                panModeBtn.textContent = 'é¸å–æ¨¡å¼ (ğŸ‘†)';
                panModeBtn.classList.add('info'); panModeBtn.classList.remove('secondary');
                canvasWrapper.classList.add('pan-mode');
                clearSelection(); 
            } else {
                panModeBtn.textContent = 'å¹³ç§»æ¨¡å¼ (ğŸ–ï¸)';
                panModeBtn.classList.add('secondary'); panModeBtn.classList.remove('info');
                canvasWrapper.classList.remove('pan-mode');
            }
        }
        
        multiSelectModeBtn.onclick = function() {
            isMultiSelectMode = !isMultiSelectMode;
            if (isMultiSelectMode) {
                if (isPanMode) panModeBtn.click(); 
                multiSelectModeBtn.textContent = 'å–®é¸æ¨¡å¼ ( M )';
                multiSelectModeBtn.classList.add('info'); multiSelectModeBtn.classList.remove('secondary');
            } else {
                multiSelectModeBtn.textContent = 'å¤šé¸æ¨¡å¼ ( M )';
                multiSelectModeBtn.classList.add('secondary'); multiSelectModeBtn.classList.remove('info');
            }
        }

        function panCanvas(e) {
            if (!isPanMode) return;
            if (e.touches && e.cancelable) e.preventDefault();
            const { x, y } = getEventCoords(e);
            const dx = x - panStartX;
            const dy = y - panStartY;
            canvasWrapper.scrollLeft = scrollStartX - dx;
            canvasWrapper.scrollTop = scrollStartY - dy;
        }
        function endPan(e) {
            if (!isPanMode) return;
            canvasWrapper.style.cursor = 'grab'; 
            document.removeEventListener('mousemove', panCanvas);
            document.removeEventListener('mouseup', endPan);
            document.removeEventListener('touchmove', panCanvas);
            document.removeEventListener('touchend', endPan);
        }

        // (*** v14.0 ä¿®æ”¹ ***) --- åŠŸèƒ½ I: ç‰©ä»¶åº« (ç§»é™¤ fontSize) ---
        const libraryItemsContainer = document.getElementById('libraryItems');
        let objectLibrary = JSON.parse(localStorage.getItem('objectLibrary') || '[]');
        
        function renderLibrary() {
            libraryItemsContainer.innerHTML = '';
            objectLibrary.forEach((itemData, index) => {
                const itemWrapper = document.createElement('div');
                itemWrapper.className = 'library-item';
                itemWrapper.title = itemData.label;
                const preview = document.createElement('div');
                preview.className = 'library-item-preview';
                
                const itemType = itemData.itemType || 'furniture';
                
                if (itemType === 'room') {
                     preview.style.backgroundColor = '#fff';
                     preview.style.border = '2px solid #ccc';
                } else if (itemType === 'text') {
                     preview.style.backgroundColor = 'transparent';
                     preview.style.border = '1px dashed #999';
                     preview.style.color = itemData.color || '#333';
                     preview.innerText = 'T';
                     preview.style.fontSize = '24px';
                     preview.style.textAlign = 'center';
                } else { // furniture
                    const rgb = hexToRgb(itemData.color);
                    const opacity = itemData.opacity || 1;
                    preview.style.backgroundColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                    if (itemData.shape === 'circle') {
                        preview.style.borderRadius = '50%';
                    } else if (itemData.shape === 'triangle-up') {
                         preview.style.backgroundColor = 'transparent';
                         preview.style.borderLeft = '20px solid transparent';
                         preview.style.borderRight = '20px solid transparent';
                         preview.style.borderBottom = `35px solid ${itemData.color}`;
                         preview.style.width = '0'; preview.style.height = '0';
                         preview.style.borderTop = 'none'; preview.style.border = 'none';
                    } else if (itemData.shape === 'trapezoid-up') {
                         preview.style.backgroundColor = 'transparent';
                         preview.style.borderBottom = `35px solid ${itemData.color}`;
                         preview.style.borderLeft = '10px solid transparent';
                         preview.style.borderRight = '10px solid transparent';
                         preview.style.width = '20px'; preview.style.height = '0';
                         preview.style.borderTop = 'none'; preview.style.border = 'none';
                    }
                }

                const label = document.createElement('span');
                label.className = 'library-item-label';
                label.textContent = itemData.label;
                const deleteButton = document.createElement('button');
                deleteButton.className = 'delete-lib-item';
                deleteButton.innerHTML = '&times;';
                deleteButton.title = 'å¾åº«ä¸­åˆªé™¤';
                deleteButton.onclick = (e) => {
                    e.stopPropagation(); 
                    if (confirm(`ç¢ºå®šè¦å¾ç‰©ä»¶åº«åˆªé™¤ "${itemData.label}" å—ï¼Ÿ`)) {
                        deleteFromLibrary(index);
                    }
                };
                itemWrapper.appendChild(preview);
                itemWrapper.appendChild(label);
                itemWrapper.appendChild(deleteButton);
                itemWrapper.onclick = () => {
                    addItemFromLibrary(itemData);
                };
                libraryItemsContainer.appendChild(itemWrapper);
            });
        }
        
        saveToLibraryBtn.onclick = function() {
            if (selectedItems.length !== 1) return;
            const item = selectedItems[0];
            const itemType = item.dataset.itemType;
            
            const itemData = {
                itemType: itemType,
                cmWidth: item.dataset.cmWidth, cmHeight: item.dataset.cmHeight,
                label: item.dataset.label, 
                // fontSize: item.dataset.fontSize, // (*** v14.0 ***) ç§»é™¤
                rotation: item.dataset.rotation
            };

            if (itemType === 'furniture') {
                itemData.color = item.dataset.colorHex;
                itemData.opacity = item.dataset.opacity;
                itemData.shape = item.dataset.shape;
            } else if (itemType === 'text') {
                itemData.color = item.dataset.colorHex;
            }
            
            const exists = objectLibrary.some(libItem => libItem.label === itemData.label && libItem.cmWidth === itemData.cmWidth && libItem.cmHeight === itemData.cmHeight && libItem.itemType === itemData.itemType);
            if (exists) {
                if (!confirm(`ç‰©ä»¶ "${itemData.label}" (${itemType}) å·²å­˜åœ¨åº«ä¸­ï¼Œæ˜¯å¦è¦†è“‹ï¼Ÿ`)) {
                    return;
                }
                objectLibrary = objectLibrary.filter(libItem => !(libItem.label === itemData.label && libItem.cmWidth === itemData.cmWidth && libItem.cmHeight === itemData.cmHeight && libItem.itemType === itemData.itemType));
            }
            objectLibrary.push(itemData);
            localStorage.setItem('objectLibrary', JSON.stringify(objectLibrary));
            renderLibrary();
            alert(`"${itemData.label}" å·²å„²å­˜è‡³ç‰©ä»¶åº«ï¼`);
        };
        
        function addItemFromLibrary(itemData) {
            saveStateForUndo("Add Item from Library");
            let newItem;
            const itemType = itemData.itemType || 'furniture';
            const positionX = (canvasWrapper.scrollLeft + canvasWrapper.offsetWidth / 2) / zoomLevel; 
            const positionY = (canvasWrapper.scrollTop + canvasWrapper.offsetHeight / 2) / zoomLevel;
            
            if (itemType === 'room') {
                newItem = createRoomElement(itemData.cmWidth, itemData.cmHeight, itemData.label, itemData.rotation);
            } else if (itemType === 'text') {
                newItem = createTextElement(itemData.label, itemData.color, itemData.rotation, itemData.cmWidth, itemData.cmHeight);
            } else { // furniture
                newItem = createFurnitureElement(itemData.cmWidth, itemData.cmHeight, itemData.shape, itemData.color, itemData.label, itemData.opacity, itemData.rotation);
            }
            
            newItem.style.left = positionX - (parseFloat(newItem.style.width)/2) + 'px'; 
            newItem.style.top = positionY - (parseFloat(newItem.style.height)/2) + 'px';
            canvas.appendChild(newItem);
            updateAndScaleLabel(newItem); 
            makeDraggable(newItem); 
            addSelectionListeners(newItem);
            setSelection(newItem); 
        }
        
        function deleteFromLibrary(index) {
             objectLibrary.splice(index, 1);
             localStorage.setItem('objectLibrary', JSON.stringify(objectLibrary));
             renderLibrary();
        }

        // (*** v14.0 ä¿®æ”¹ ***) --- åŠŸèƒ½ J: æ–°å¢é …ç›® (ç§»é™¤ fontSize) ---
        
        // J-1: æ–°å¢æˆ¿é–“
        addRoomBtn.onclick = function() {
            saveStateForUndo("Add Room");
            const roomWidth = document.getElementById('roomWidth').value, roomHeight = document.getElementById('roomHeight').value;
            const roomLabel = document.getElementById('roomLabel').value;
            // const roomFontSize = document.getElementById('roomFontSize').value; // (*** v14.0 ***) ç§»é™¤
            const roomRotation = document.getElementById('roomRotation').value;
            
            const room = createRoomElement(roomWidth, roomHeight, roomLabel, roomRotation);
            room.style.left = (canvasWrapper.scrollLeft + 50) / zoomLevel + 'px';
            room.style.top = (canvasWrapper.scrollTop + 50) / zoomLevel + 'px';
            
            canvas.appendChild(room);
            updateAndScaleLabel(room); 
            makeDraggable(room);
            addSelectionListeners(room);
            setSelection(room);
        };
        
        // J-2: æ–°å¢å®¶å…·
        addFurnitureBtn.onclick = function() {
            saveStateForUndo("Add Furniture");
            const width = document.getElementById('furnWidth').value, height = document.getElementById('furnHeight').value;
            const shape = document.getElementById('furnShape').value, color = document.getElementById('furnColor').value;
            const label = document.getElementById('furnLabel').value, opacity = opacitySlider.value / 100;
            // const fontSize = document.getElementById('furnFontSize').value; // (*** v14.0 ***) ç§»é™¤
            const rotation = document.getElementById('furnRotation').value;
            
            const furniture = createFurnitureElement(width, height, shape, color, label, opacity, rotation);
            furniture.style.left = (canvasWrapper.scrollLeft + 50) / zoomLevel + 'px';
            furniture.style.top = (canvasWrapper.scrollTop + 50) / zoomLevel + 'px';
            
            canvas.appendChild(furniture);
            updateAndScaleLabel(furniture);
            makeDraggable(furniture);
            addSelectionListeners(furniture);
            setSelection(furniture);
        };

        // J-3: æ–°å¢æ–‡å­—
        addTextBtn.onclick = function() {
            saveStateForUndo("Add Text");
            const label = document.getElementById('textLabel').value;
            // const fontSize = document.getElementById('textFontSize').value; // (*** v14.0 ***) ç§»é™¤
            const color = document.getElementById('textColor').value, rotation = document.getElementById('textRotation').value;
            const width = document.getElementById('textWidth').value, height = document.getElementById('textHeight').value;

            const textObj = createTextElement(label, color, rotation, width, height);
            textObj.style.left = (canvasWrapper.scrollLeft + 50) / zoomLevel + 'px';
            textObj.style.top = (canvasWrapper.scrollTop + 50) / zoomLevel + 'px';

            canvas.appendChild(textObj);
            updateAndScaleLabel(textObj);
            makeDraggable(textObj);
            addSelectionListeners(textObj);
            setSelection(textObj);
        };


        // (*** v14.0 ä¿®æ”¹ ***) --- åŠŸèƒ½ K: å»ºç«‹å…ƒç´  DOM & æ¨™ç±¤ (ç§»é™¤ fontSize) ---

        // K-1: å»ºç«‹æˆ¿é–“
        function createRoomElement(width, height, label, rotation = 0, id = null) {
            const room = document.createElement('div');
            room.className = 'room';
            room.dataset.id = id || `room-${Date.now()}`; 
            room.dataset.itemType = 'room';
            room.dataset.cmWidth = width; room.dataset.cmHeight = height;
            room.dataset.label = label; 
            // room.dataset.fontSize = fontSize; // (*** v14.0 ***) ç§»é™¤
            room.dataset.rotation = rotation;
            room.dataset.isLocked = 'false';
            room.style.width = (width * SCALE) + 'px'; room.style.height = (height * SCALE) + 'px';
            // room.style.setProperty('--font-size', fontSize + 'px'); // (*** v14.0 ***) ç§»é™¤
            room.style.transform = 'rotate(' + rotation + 'deg)';
            room.style.zIndex = Z_INDEX_ROOM_BASE; 
            return room;
        }

        // K-2: å»ºç«‹å®¶å…·
        function createFurnitureElement(width, height, shape, color, label, opacity = 1, rotation = 0, id = null) {
            const furniture = document.createElement('div');
            furniture.className = 'furniture';
            furniture.dataset.id = id || `furn-${Date.now()}`; 
            furniture.dataset.itemType = 'furniture';
            furniture.dataset.cmWidth = width; furniture.dataset.cmHeight = height;
            furniture.dataset.label = label; furniture.dataset.colorHex = color;
            furniture.dataset.opacity = opacity; 
            // furniture.dataset.fontSize = fontSize; // (*** v14.0 ***) ç§»é™¤
            furniture.dataset.rotation = rotation;
            furniture.dataset.shape = shape;
            furniture.dataset.isLocked = 'false';
            furniture.style.width = (width * SCALE) + 'px'; furniture.style.height = (height * SCALE) + 'px';
            // furniture.style.setProperty('--font-size', fontSize + 'px'); // (*** v14.0 ***) ç§»é™¤
            furniture.style.transform = 'rotate(' + rotation + 'deg)';
            furniture.style.zIndex = Z_INDEX_FURN_BASE; 
            const rgb = hexToRgb(color);
            furniture.style.backgroundColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
            applyShape(furniture, shape);
            return furniture;
        }

        // K-3: å»ºç«‹æ–‡å­—ç‰©ä»¶
        function createTextElement(label, color = '#333333', rotation = 0, width = 150, height = 50, id = null) {
            const textObj = document.createElement('div');
            textObj.className = 'furniture text-object';
            textObj.dataset.id = id || `text-${Date.now()}`; 
            textObj.dataset.itemType = 'text';
            textObj.dataset.cmWidth = width; textObj.dataset.cmHeight = height;
            textObj.dataset.label = label; textObj.dataset.colorHex = color;
            // textObj.dataset.fontSize = fontSize; // (*** v14.0 ***) ç§»é™¤
            textObj.dataset.rotation = rotation;
            textObj.dataset.isLocked = 'false';
            textObj.style.width = (width * SCALE) + 'px'; textObj.style.height = (height * SCALE) + 'px';
            // textObj.style.setProperty('--font-size', fontSize + 'px'); // (*** v14.0 ***) ç§»é™¤
            textObj.style.transform = 'rotate(' + rotation + 'deg)';
            textObj.style.zIndex = Z_INDEX_FURN_BASE;
            textObj.style.backgroundColor = 'transparent';
            textObj.style.border = '1px dashed #999';
            textObj.style.color = color;
            textObj.style.setProperty('--text-color', color);
            return textObj;
        }

        // K-4: æ‡‰ç”¨å½¢ç‹€ (ç„¡è®Šæ›´)
        function applyShape(element, shape) {
            element.style.borderRadius = '0';
            element.style.clipPath = 'none';

            if (shape === 'circle') {
                element.style.borderRadius = '50%';
            } else if (shape === 'triangle-up') {
                element.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';
            } else if (shape === 'trapezoid-up') {
                element.style.clipPath = 'polygon(20% 0%, 80% 0%, 100% 100%, 0% 100%)';
            }
        }

        // (*** v14.0 é‡å¤§ä¿®æ­£ ***) K-5: æ›´æ–°ä¸¦è‡ªå‹•ç¸®æ”¾æ¨™ç±¤ (ä¿®æ­£ v13.0 çš„ Bug)
        function updateAndScaleLabel(element) {
            element.innerHTML = ''; // æ¸…ç©ºèˆŠæ¨™ç±¤
            const label = element.dataset.label;
            const itemType = element.dataset.itemType;
            
            let labelText = label;
            // (*** v14.0 ***) åˆä½µæ¨™ç±¤èˆ‡å°ºå¯¸
            if (itemType === 'room' || itemType === 'furniture') {
                const cmWidth = element.dataset.cmWidth;
                const cmHeight = element.dataset.cmHeight;
                if (label) {
                    labelText = `${label} (${cmWidth}x${cmHeight}cm)`;
                } else {
                    labelText = `(${cmWidth}x${cmHeight}cm)`; // è™•ç†ç©ºå‚™è¨»
                }
            }
            
            let labelClass = (itemType === 'room') ? 'room-label' : 'furniture-label';
            
            const labelMain = document.createElement('span');
            labelMain.className = labelClass;
            labelMain.innerText = labelText;
            
            if (itemType === 'text') {
                labelMain.style.color = element.dataset.colorHex;
            }

            element.appendChild(labelMain);

            // --- (*** v14.0 ***) ä¿®æ­£çš„è‡ªå‹•ç¸®æ”¾é‚è¼¯ (Ratio-based) ---
            
            // å¦‚æœæ¨™ç±¤ç‚ºç©º (ä¾‹å¦‚æ–‡å­—ç‰©ä»¶æ²’æ‰“å­—)ï¼Œéš±è—ä¸¦è¿”å›
            if (!labelText) {
                 labelMain.style.display = 'none';
                 return;
            }

            const elWidth = parseFloat(element.style.width);
            const elHeight = parseFloat(element.style.height);
            const minFontSize = 8; // æœ€å° 8px

            if (elWidth < 10 || elHeight < 10) {
                 labelMain.style.display = 'none';
                 return;
            }

            const maxWidth = elWidth * 0.7;
            const maxHeight = elHeight * 0.7;

            // 1. èµ·å§‹å­—é«”å¤§å° = 70% çš„é«˜åº¦
            let currentFontSize = Math.max(minFontSize, maxHeight);
            labelMain.style.fontSize = currentFontSize + 'px';
            labelMain.style.whiteSpace = 'nowrap'; // å¿…é ˆæ˜¯å–®è¡Œ
            
            // 2. ç²å–åœ¨è©²å­—é«”å¤§å°ä¸‹çš„å¯¬åº¦
            const scrollWidthAtMaxHeight = labelMain.scrollWidth;
            
            // 3. æª¢æŸ¥æ˜¯å¦å¤ªå¯¬
            if (scrollWidthAtMaxHeight > maxWidth) {
                // 4. å¤ªå¯¬äº†. æ ¹æ“šå¯¬åº¦æ¯”ä¾‹ç¸®å°å­—é«”
                const widthRatio = maxWidth / scrollWidthAtMaxHeight;
                currentFontSize = Math.max(minFontSize, currentFontSize * widthRatio);
            }

            // 5. ç¢ºä¿å­—é«”ä¸å°æ–¼æœ€å°å€¼
            currentFontSize = Math.max(minFontSize, currentFontSize);
            
            // 6. æ‡‰ç”¨æœ€çµ‚è¨ˆç®—çš„å­—é«”å¤§å°
            labelMain.style.fontSize = currentFontSize + 'px';

            // 7. æœ€å¾Œçš„å¯è¦‹æ€§æª¢æŸ¥ (å¦‚æœ 8px é‚„æ˜¯å¤ªå¤§)
            // (ä½¿ç”¨ 100% å¯¬é«˜æª¢æŸ¥, é¿å… 70% çš„é‚Šç•Œå•é¡Œ)
            if (labelMain.scrollWidth > elWidth || labelMain.scrollHeight > elHeight) {
                 labelMain.style.display = 'none';
            } else {
                 labelMain.style.display = 'block';
                 labelMain.style.position = 'relative'; 
            }
        }


        // --- åŠŸèƒ½ L: çµ±ä¸€çš„æ‹–æ›³å‡½å¼ (v12.0) (ç„¡è®Šæ›´) ---
        function makeDraggable(element) {
            let isDragging = false;
            let currentDragTargets = []; 
            let dragStartPositions = []; 
            let hasMoved = false;

            function onDragStart(e) {
                if (isPanMode) return;
                if (e.target.closest('#floating-toolbar')) return;

                if (element.dataset.isLocked === 'true') {
                    return;
                }
                
                if (!selectedItems.includes(element)) {
                    return;
                }
                if (selectedItems.some(item => item.dataset.isLocked === 'true')) {
                    return; 
                }
                
                currentDragTargets = [...selectedItems];
                if (currentDragTargets.length === 0) return; 

                e.stopPropagation(); 
                isDragging = true;
                hasMoved = false;
                stateBeforeDrag = getCurrentState(); 

                dragStartPositions = currentDragTargets.map(item => ({
                    element: item,
                    startX: item.offsetLeft,
                    startY: item.offsetTop
                }));

                const { x, y } = getEventCoords(e);
                const canvasRect = canvas.getBoundingClientRect();
                const pointerStartX = (x / zoomLevel) - (canvasRect.left / zoomLevel);
                const pointerStartY = (y / zoomLevel) - (canvasRect.top / zoomLevel);
                
                const referenceElement = element;
                dragOffsetX = pointerStartX - referenceElement.offsetLeft;
                dragOffsetY = pointerStartY - referenceElement.offsetTop;

                currentDragTargets.forEach(item => {
                    const currentZ = parseInt(item.style.zIndex || (item.classList.contains('room') ? Z_INDEX_ROOM_BASE : Z_INDEX_FURN_BASE));
                    item.style.zIndex = currentZ + 1000; 
                    item.style.transition = 'none'; 
                });
                
                floatingToolbar.classList.remove('visible');

                document.addEventListener('mousemove', onDragMove);
                document.addEventListener('mouseup', onDragEnd);
                document.addEventListener('touchmove', onDragMove, { passive: false }); 
                document.addEventListener('touchend', onDragEnd);
            }

            function onDragMove(e) {
                if (!isDragging) return;
                if (e.cancelable && e.type === 'touchmove') e.preventDefault(); 
                hasMoved = true;
                
                const { x, y } = getEventCoords(e);
                const canvasRect = canvas.getBoundingClientRect();
                const pointerX = (x / zoomLevel) - (canvasRect.left / zoomLevel);
                const pointerY = (y / zoomLevel) - (canvasRect.top / zoomLevel);

                const referenceStart = dragStartPositions.find(p => p.element === element);
                if (!referenceStart) { console.error("Drag reference lost."); return; }
                
                const targetNewX = pointerX - dragOffsetX;
                const targetNewY = pointerY - dragOffsetY;
                let dx = targetNewX - referenceStart.startX;
                let dy = targetNewY - referenceStart.startY;

                const firstItem = referenceStart.element;
                let firstItemNewX = referenceStart.startX + dx;
                let firstItemNewY = referenceStart.startY + dy;
                const rotation = parseFloat(firstItem.dataset.rotation) || 0;
                const isAxisAligned = (rotation % 90 === 0);
                let effectiveWidth = firstItem.clientWidth, effectiveHeight = firstItem.clientHeight;
                 if (isAxisAligned && (rotation % 180 !== 0) && rotation !== 0) { 
                    effectiveWidth = firstItem.clientHeight; effectiveHeight = firstItem.clientWidth;
                }
                
                let isColliding = false;

                // å¸é™„ (Snapping)
                if (document.getElementById('enableSnapping').checked && isAxisAligned) {
                    let snappedX = false, snappedY = false;
                    let potentialSnapX = firstItemNewX;
                    let potentialSnapY = firstItemNewY;
                    const myLeft = firstItemNewX, myRight = firstItemNewX + effectiveWidth, myTop = firstItemNewY, myBottom = firstItemNewY + effectiveHeight;
                    const otherItems = Array.from(canvas.querySelectorAll('.room, .furniture, .text-object')).filter(el => !currentDragTargets.includes(el));
                    for (const other of otherItems) {
                        const oLeft = other.offsetLeft, oTop = other.offsetTop;
                        const otherRotation = parseFloat(other.dataset.rotation) || 0;
                         const otherIsAxisAligned = (otherRotation % 90 === 0);
                         if (!otherIsAxisAligned) continue;

                         let otherEffectiveWidth = other.clientWidth, otherEffectiveHeight = other.clientHeight;
                         if ((otherRotation % 180 !== 0) && otherRotation !== 0) {
                            otherEffectiveWidth = other.clientHeight; otherEffectiveHeight = other.clientWidth;
                         }
                         const oEffectiveRight = oLeft + otherEffectiveWidth;
                         const oEffectiveBottom = oTop + otherEffectiveHeight;
                        
                        if (!snappedX) {
                            if (Math.abs(myLeft - oEffectiveRight) < SNAP_DISTANCE) { potentialSnapX = oEffectiveRight; snappedX = true; }
                            else if (Math.abs(myRight - oLeft) < SNAP_DISTANCE) { potentialSnapX = oLeft - effectiveWidth; snappedX = true; }
                            else if (Math.abs(myLeft - oLeft) < SNAP_DISTANCE) { potentialSnapX = oLeft; snappedX = true; } 
                            else if (Math.abs(myRight - oEffectiveRight) < SNAP_DISTANCE) { potentialSnapX = oEffectiveRight - effectiveWidth; snappedX = true; } 
                        }
                        if (!snappedY) {
                             if (Math.abs(myTop - oEffectiveBottom) < SNAP_DISTANCE) { potentialSnapY = oEffectiveBottom; snappedY = true; }
                             else if (Math.abs(myBottom - oTop) < SNAP_DISTANCE) { potentialSnapY = oTop - effectiveHeight; snappedY = true; }
                             else if (Math.abs(myTop - oTop) < SNAP_DISTANCE) { potentialSnapY = oTop; snappedY = true; } 
                             else if (Math.abs(myBottom - oEffectiveBottom) < SNAP_DISTANCE) { potentialSnapY = oEffectiveBottom - effectiveHeight; snappedY = true; } 
                        }
                    }
                    if (snappedX || snappedY) {
                         firstItemNewX = potentialSnapX; 
                         firstItemNewY = potentialSnapY; 
                         dx = firstItemNewX - referenceStart.startX; 
                         dy = firstItemNewY - referenceStart.startY; 
                    }
                }

                // å¥—ç”¨æœ€çµ‚ä½ç§»
                dragStartPositions.forEach((startPos) => {
                     const item = startPos.element;
                     item.style.left = startPos.startX + dx + 'px';
                     item.style.top = startPos.startY + dy + 'px';
                 });
                
                // ç¢°æ’ (Collision)
                if (document.getElementById('preventOverlap').checked && isAxisAligned) {
                    const otherFurn = Array.from(canvas.querySelectorAll('.furniture')).filter(el => !currentDragTargets.includes(el));
                    for (const sibling of otherFurn) {
                         const siblingRotation = parseFloat(sibling.dataset.rotation) || 0;
                         if (siblingRotation % 90 !== 0) continue; 
                         let siblingEffectiveWidth = sibling.clientWidth;
                         let siblingEffectiveHeight = sibling.clientHeight;
                         if ((siblingRotation % 180 !== 0) && siblingRotation !== 0) {
                            siblingEffectiveWidth = sibling.clientHeight; siblingEffectiveHeight = sibling.clientWidth;
                         }
                        const sRect = { left: sibling.offsetLeft, top: sibling.offsetTop, right: sibling.offsetLeft + siblingEffectiveWidth, bottom: sibling.offsetTop + siblingEffectiveHeight };
                        const eRect = { left: firstItemNewX, top: firstItemNewY, right: firstItemNewX + effectiveWidth, bottom: firstItemNewY + effectiveHeight };
                        if (eRect.left < sRect.right && eRect.right > sRect.left && eRect.top < sRect.bottom && eRect.bottom > sRect.top) {
                            isColliding = true; break;
                        }
                    }
                }
                 currentDragTargets.forEach(item => {
                    if (isColliding) {
                        item.classList.add('colliding');
                    } else {
                        item.classList.remove('colliding');
                        item.dataset.lastValidX = item.offsetLeft; 
                        item.dataset.lastValidY = item.offsetTop;
                    }
                 });
            } 

            function onDragEnd(e) {
                if (!isDragging) return;
                isDragging = false;

                if (hasMoved) {
                    updateFloatingToolbarPosition();
                }
                floatingToolbar.classList.add('visible');

                let stateWasSaved = false;
                if (hasMoved && stateBeforeDrag) {
                    const collisionHappened = currentDragTargets.some(item => item.classList.contains('colliding'));
                    if (collisionHappened && document.getElementById('preventOverlap').checked) {
                         currentDragTargets.forEach((item, i) => {
                             const lastX = item.dataset.lastValidX !== undefined ? item.dataset.lastValidX + 'px' : dragStartPositions[i].startX + 'px';
                             const lastY = item.dataset.lastValidY !== undefined ? item.dataset.lastValidY + 'px' : dragStartPositions[i].startY + 'px';
                             item.style.left = lastX;
                             item.style.top = lastY;
                             item.classList.remove('colliding');
                             delete item.dataset.lastValidX;
                             delete item.dataset.lastValidY;
                         });
                         stateBeforeDrag = null;
                         updateFloatingToolbarPosition();
                    } else {
                        redoStack = [];
                        historyStack.push(stateBeforeDrag);
                        updateUndoRedoButtons();
                        stateWasSaved = true;
                        currentDragTargets.forEach(item => {
                            delete item.dataset.lastValidX;
                            delete item.dataset.lastValidY;
                        });
                    }
                }
                stateBeforeDrag = null; 

                currentDragTargets.forEach(item => {
                    const itemType = item.dataset.itemType;
                    const baseZ = itemType === 'room' ? Z_INDEX_ROOM_BASE : Z_INDEX_FURN_BASE;
                     
                     const originalZ = stateWasSaved && historyStack[historyStack.length-1]?.layout 
                        ? (itemType === 'room'
                           ? historyStack[historyStack.length-1].layout.rooms.find(r=>r.id===item.dataset.id)?.zIndex
                           : (itemType === 'furniture' 
                                ? historyStack[historyStack.length-1].layout.furniture.find(f=>f.id===item.dataset.id)?.zIndex
                                : historyStack[historyStack.length-1].layout.textObjects.find(t=>t.id===item.dataset.id)?.zIndex
                             )
                          )
                        : null;
                     item.style.zIndex = originalZ || baseZ; 
                    item.style.transition = 'left 0.1s ease-out, top 0.1s ease-out, background-color 0.2s, transform 0.2s, box-shadow 0.2s, clip-path 0.2s';
                    item.classList.remove('colliding'); 
                });

                currentDragTargets = [];
                dragStartPositions = [];

                document.removeEventListener('mousemove', onDragMove);
                document.removeEventListener('mouseup', onDragEnd);
                document.removeEventListener('touchmove', onDragMove);
                document.removeEventListener('touchend', onDragEnd);

                updateSelectionUI();
            }
            element.addEventListener('mousedown', onDragStart);
            addSelectionListeners(element);
        }

        // --- åˆå§‹è¨­å®š (ç„¡è®Šæ›´) ---
        renderLibrary(); 
        updateUndoRedoButtons();
         if(historyStack.length === 0) {
             historyStack.push(getCurrentState());
             updateUndoRedoButtons();
         }

    </script>
</body>
</html>
