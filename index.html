<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI äº¤æ˜“æŠ€è¡“åˆ†æ</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; margin: 10px; }
        table { width: 100%; margin: 10px auto; border-collapse: collapse; font-size: 14px; }
        th, td { padding: 8px; border: 1px solid #ddd; }
        th { background-color: #f4f4f4; cursor: help; }
        #update-time { font-size: 14px; margin: 10px; }
        #history-log { width: 90%; margin: 20px auto; border: 1px solid #ddd; padding: 10px; height: 150px; overflow-y: auto; background: #f9f9f9; text-align: left; }
    </style>
</head>
<body>
    <h1>ğŸ“ˆ AI äº¤æ˜“æŠ€è¡“åˆ†æ ğŸ“Š</h1>
    <p id="update-time">æœ€æ–°æ•¸æ“šæ›´æ–°æ™‚é–“ï¼š-</p>
    <p id="error-message" class="error" style="color: red;"></p>
    <div id="history-log">
        <strong>ğŸ“Œ æŠ€è¡“æŒ‡æ¨™æ ¡æ­£æ­·å²ï¼š</strong>
        <ul id="history-list"></ul>
    </div>
    <table>
        <thead>
            <tr>
                <th>å¹£ç¨®</th>
                <th>åƒ¹æ ¼ (USD)</th>
                <th>RSI</th>
                <th>MACD</th>
                <th>å¸ƒæ—é€šé“</th>
                <th>VWAP</th>
                <th>é æ¸¬æˆåŠŸç‡ (%)</th>
                <th>æœ€ä½³æŠ€è¡“æŒ‡æ¨™è¨­å®š</th>
            </tr>
        </thead>
        <tbody id="crypto-table"></tbody>
    </table>

    <script>
        const binanceApiUrl = "https://api.binance.com/api/v3/klines";
        const symbols = ["BTCUSDT", "ETHUSDT", "BNBUSDT", "SOLUSDT", "XRPUSDT", "ADAUSDT"];
        const indicatorsHistory = {};  // è¨˜éŒ„æŠ€è¡“æŒ‡æ¨™æˆåŠŸ/å¤±æ•—æ¬¡æ•¸

        async function fetchCryptoData() {
            try {
                let data = [];
                for (let symbol of symbols) {
                    const response = await fetch(`${binanceApiUrl}?symbol=${symbol}&interval=1h&limit=24`);
                    if (!response.ok) throw new Error(`Binance API éŒ¯èª¤: ${response.status}`);
                    const coin = await response.json();
                    data.push({ symbol: symbol, history: coin });
                }
                updateTable(data);
                document.getElementById("update-time").textContent = `æœ€æ–°æ•¸æ“šæ›´æ–°æ™‚é–“ï¼š${new Date().toLocaleString()}`;
            } catch (error) {
                console.error("ç²å–æ•¸æ“šå¤±æ•—:", error);
                document.getElementById("error-message").textContent = "âš ï¸ ç„¡æ³•ç²å–æ•¸æ“šï¼Œè«‹ç¨å¾Œå†è©¦...";
            }
        }

        function updateTable(data) {
            const tableBody = document.getElementById("crypto-table");
            tableBody.innerHTML = "";

            data.forEach(coin => {
                let symbol = coin.symbol;
                let successCount = 0, failureCount = 0;
                let bestRSI = 50, bestMACD = "é»ƒé‡‘äº¤å‰", bestBollinger = "ä¸­è»Œ";
                
                for (let i = 1; i < coin.history.length; i++) {
                    let latestPrice = parseFloat(coin.history[i][4]); // ç•¶å‰æ”¶ç›¤åƒ¹
                    let previousPrice = parseFloat(coin.history[i - 1][4]); // å‰ä¸€å°æ™‚åƒ¹æ ¼
                    let priceChange = (latestPrice - previousPrice) / previousPrice * 100;

                    let rsi = calculateRSI(coin.history, i);
                    let macd = getRandomChoice(["é»ƒé‡‘äº¤å‰", "æ­»äº¡äº¤å‰"]);
                    let bollinger = getRandomChoice(["ä¸Šè»Œ", "ä¸­è»Œ", "ä¸‹è»Œ"]);
                    let vwap = getRandomChoice(["ä¸Šå‡", "ä¸‹é™"]);

                    // è¨˜éŒ„æŠ€è¡“æŒ‡æ¨™çš„æˆåŠŸèˆ‡å¤±æ•—
                    if ((rsi < 30 && priceChange > 0) || (rsi > 70 && priceChange < 0)) {
                        successCount++;
                        bestRSI = rsi;
                    } else {
                        failureCount++;
                    }

                    if ((macd === "é»ƒé‡‘äº¤å‰" && priceChange > 0) || (macd === "æ­»äº¡äº¤å‰" && priceChange < 0)) {
                        successCount++;
                        bestMACD = macd;
                    } else {
                        failureCount++;
                    }

                    if ((bollinger === "ä¸‹è»Œ" && priceChange > 0) || (bollinger === "ä¸Šè»Œ" && priceChange < 0)) {
                        successCount++;
                        bestBollinger = bollinger;
                    } else {
                        failureCount++;
                    }
                }

                let totalPredictions = successCount + failureCount;
                let accuracy = totalPredictions > 0 ? (successCount / totalPredictions * 100).toFixed(2) : "N/A";

                const row = document.createElement("tr");
                row.innerHTML = `
                    <td>${symbol}</td>
                    <td>$${parseFloat(coin.history[coin.history.length - 1][4]).toFixed(2)}</td>
                    <td>æœ€ä½³ RSI: ${bestRSI.toFixed(2)}</td>
                    <td>æœ€ä½³ MACD: ${bestMACD}</td>
                    <td>æœ€ä½³å¸ƒæ—: ${bestBollinger}</td>
                    <td>VWAP: ${vwap}</td>
                    <td>${accuracy}%</td>
                    <td>
                        <strong>æœ€ä½³æŠ€è¡“æŒ‡æ¨™:</strong> <br>
                        RSI < 30: ${bestRSI < 30 ? "âœ…" : "âŒ"} <br>
                        MACD é»ƒé‡‘äº¤å‰: ${bestMACD === "é»ƒé‡‘äº¤å‰" ? "âœ…" : "âŒ"} <br>
                        å¸ƒæ—é€šé“ä¸‹è»Œ: ${bestBollinger === "ä¸‹è»Œ" ? "âœ…" : "âŒ"} <br>
                    </td>
                `;
                tableBody.appendChild(row);
            });
        }

        function calculateRSI(history, index) {
            let gains = 0, losses = 0;
            for (let i = index - 14; i < index; i++) {
                if (i < 0) continue;
                let change = parseFloat(history[i][4]) - parseFloat(history[i - 1][4]);
                if (change > 0) gains += change;
                else losses -= change;
            }
            let avgGain = gains / 14;
            let avgLoss = losses / 14;
            let rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        }

        function getRandomChoice(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        setInterval(fetchCryptoData, 3000); // æ¯ 1 åˆ†é˜æ›´æ–°ä¸€æ¬¡
        fetchCryptoData();
    </script>
</body>
</html>
